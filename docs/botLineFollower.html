<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Linienfolger mit mehreren IR-Sensoren (PID Regler) · Let&#x27;s rule the bots!  </title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="Für den Kantenfolger wurde der einfache, aber dennoch effiziente [P-Regler](botEdge_P_Control) zum Folgen der Kanten verwendet. Der P-Regler funktioniert mit dem richtigen Proportionalitätsfaktor \\(k_p\\) in der Regel sehr zuverlässig. Trotzdem neigt er aber zu starken Oszillationsbewegungen, d.h. er wackelt an der Kante entlang, anstatt dieser ruhig zu folgen. Bevor im folgenden schrittweise der PID-Regler eingeführt wird, soll noch einmal kurz der Pseudocode des P-Regler erläutert werden."/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Linienfolger mit mehreren IR-Sensoren (PID Regler) · Let&#x27;s rule the bots!  "/><meta property="og:type" content="website"/><meta property="og:url" content="https://spacehal.github.io/"/><meta property="og:description" content="Für den Kantenfolger wurde der einfache, aber dennoch effiziente [P-Regler](botEdge_P_Control) zum Folgen der Kanten verwendet. Der P-Regler funktioniert mit dem richtigen Proportionalitätsfaktor \\(k_p\\) in der Regel sehr zuverlässig. Trotzdem neigt er aber zu starken Oszillationsbewegungen, d.h. er wackelt an der Kante entlang, anstatt dieser ruhig zu folgen. Bevor im folgenden schrittweise der PID-Regler eingeführt wird, soll noch einmal kurz der Pseudocode des P-Regler erläutert werden."/><meta property="og:image" content="https://spacehal.github.io/img/undraw_online.svg"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://spacehal.github.io/img/undraw_tweetstorm.svg"/><link rel="shortcut icon" href="/img/LogoSmallRed.svg"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/agate.min.css"/><link rel="alternate" type="application/atom+xml" href="https://spacehal.github.io/blog/atom.xml" title="Let&#x27;s rule the bots!   Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://spacehal.github.io/blog/feed.xml" title="Let&#x27;s rule the bots!   Blog RSS Feed"/><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Zilla+Slab:300,300i,500,600"/><link rel="stylesheet" href="/css/code-block-buttons.css"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML"></script><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="/img/LogoSmallRed.svg" alt="Let&#x27;s rule the bots!  "/><h2 class="headerTitleWithLogo">Let&#x27;s rule the bots!  </h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/docs/helloworld" target="_self">Arduino</a></li><li class="siteNavGroupActive"><a href="/docs/botEdgeFollower" target="_self">Robotik</a></li><li class=""><a href="/docs/zumoInstallation" target="_self">Zumo</a></li><li class=""><a href="/docs/moreInfo" target="_self">Links</a></li><li class=""><a href="/blog/" target="_self">Blog</a></li><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Linienfolger</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">Linienfolger<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/botEdgeFollower">3-Stufen-Regler (Kantenfolger)</a></li><li class="navListItem"><a class="navItem" href="/docs/botEdge_P_Control">P-Regler (Kantenfolger)</a></li><li class="navListItem"><a class="navItem" href="/docs/botWeightedAverage">Gewichteter Mittelwert</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/docs/botLineFollower">PID-Regler</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">Hindernisserkennung<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/botObstacle">Suchen, Finden, Ausweichen</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 class="postHeaderTitle">Linienfolger mit mehreren IR-Sensoren (PID Regler)</h1></header><article><div><span><p>Für den Kantenfolger wurde der einfache, aber dennoch effiziente <a href="botEdge_P_Control">P-Regler</a> zum Folgen der Kanten verwendet. Der P-Regler funktioniert mit dem richtigen Proportionalitätsfaktor \(k_p\) in der Regel sehr zuverlässig. Trotzdem neigt er aber zu starken Oszillationsbewegungen, d.h. er wackelt an der Kante entlang, anstatt dieser ruhig zu folgen. Bevor im folgenden schrittweise der PID-Regler eingeführt wird, soll noch einmal kurz der Pseudocode des P-Regler erläutert werden.</p>
<h2><a class="anchor" aria-hidden="true" id="p-regler"></a><a href="#p-regler" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>P-Regler</h2>
<pre><code class="hljs css language-C"><span class="hljs-comment">// Linienfolger mit 5 Sensoren        </span>

wertLinie = <span class="hljs-number">2000</span>                          <span class="hljs-comment">// Sollwert (Sensorwert genau über der Linie)</span>
kp        = <span class="hljs-number">1</span>                             <span class="hljs-comment">// Proportional-Faktor</span>

wiederhole
    position   = leseLinie()              <span class="hljs-comment">// Position sei ein Wert zwischen  0 und 4000</span>
                                          <span class="hljs-comment">// Position = 2000 bedeutet, genau über der Linie</span>
    error      = position - wertLinie     <span class="hljs-comment">// Fehlerwert, Regeldifferenz</span>
    deltaSpeed = error * kp               <span class="hljs-comment">// P-Regler - Ändert die Geschwindigkeit</span>
    leftSpeed  = leftSpeed - deltaSpeed   <span class="hljs-comment">// Drehzahl links bestimmen</span>
    rightSpeed = rightSpeed + deltaSpeed  <span class="hljs-comment">// Drehzahl rechts bestimmen</span>

    begrenze(leftSpeed)                   <span class="hljs-comment">// Drehzahl auf sinnvolle Werte begrenzen</span>
    begrenze(rightSpeed)
    setMotors(leftSpeed,rightSpeed)       <span class="hljs-comment">// Aktualisieren der Motordrehzahlen</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="integral-anteil"></a><a href="#integral-anteil" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Integral-Anteil</h2>
<p>Zum Vermeiden von Oszillationsbewegungen wird der Proportionalregler um einen <strong>Integralanteil</strong> erweitert (I-Anteil). Der Integralanteil gibt dem Regler ein <em>Gedächtnis</em>, wodurch Abweichungen von der Sollgröße (also der Fehlerwert), die über einen langen Zeitraum bestehen, besonders berücksichtigt werden.</p>
<p>Aus mathematischer Sicht entspricht dieses Gedächtnis dem <strong>Aufsummieren aller Fehler</strong> oder auch dem <a href="https://de.wikipedia.org/wiki/Regler#I-Regler_(I-Anteil)">Integral aller Fehler</a> über die Zeit.
$$ \int_0^t e(t) \text{ d}t \approx e(t_0)\ \cdot \Delta t + e(t_1)\ \cdot \Delta t + \cdots $$
Für den Pseudocode kann das Integral mit Hilfe der einzelnen Summen \( e(t_0)\cdot \Delta t \) berechnet werden. Zu jedem neuen Zeitpunkt wird zu dem bereits berechnetem Integral-Wert der neue Fehler \( e(t_0)\cdot \Delta t \) hinzuaddiert. Dadurch wird aus dem  komplizierten Integral eine sehr einfache Rechnung:</p>
<pre><code class="hljs css language-c">integral = integral + error * dTime <span class="hljs-comment">// Aufsummieren des Fehler zum Integralanteil</span>
</code></pre>
<p>Wenn das <strong>Zeitintervall <code>dTime</code> zwischen den Messerwerten immer gleich</strong> ist (oder zumindest sehr ähnlich), kann auf die Multiplikation mit <code>dTime</code> verzichtet werden.</p>
<pre><code class="hljs css language-C">integral = integral + error <span class="hljs-comment">// Aufaddieren des Fehlers liefert den Integralanteil</span>
</code></pre>
<p>Das vereinfacht den Code ein wenig, macht den Algorithmus aber auch anfällig für Fehler, wenn zwischen verschiedenen Messungen unterschiedlich viel Zeit vergeht. Wenn der Roboter also neben der Linienerkennung auch noch Kreuzungen, Hindernisse oder andere Fahrzeuge erkennen soll, muss enteweder auf ein immer gleiches <code>dTime</code> geachtet werden, oder das <code>dTime</code> in dem Algorithmus jedes mal berechnet werden werden.</p>
<hr>
<blockquote>
<p>Warum wird der Integralanteil nicht unendlich groß, wenn alle Fehler aufaddiert werden?</p>
</blockquote>
<p>Da der Fehler positiv und negativ sein kann, wird der Integralanteil nur dann anwachsen, wenn sich der Fehler für eine längere Zeit nicht ändert. Genau solche, über einen gewissen Zeitraum bestehenden Fehler, soll der Integralanteil kompensieren</p>
<hr>
<p>Zur Regelung der Motorgeschwindigkeit wird der Integral-Anteil, ähnlich wie der Proportional-Anteil mit einem Faktor \(k_i\) gewichtet. Für die Geschwindigkeitsänderung <code>deltaSpeed</code> ergibt sich mit dem P-Anteil folgender Pseudocode:</p>
<pre><code class="hljs css language-C">integral   = integral + error             <span class="hljs-comment">// Aufsummieren des Fehler zum Integralanteil</span>
deltaSpeed = error * kp + integral * ki   <span class="hljs-comment">// PI-Regler mit den Faktoren kp und ki</span>
</code></pre>
<p>Für den vollständige Pseudocode des PI-Reglers (Proportional-Integral-Reglers) wird von konstanten Zeitintervallen zwischen den Messungen ausgegangen und der <code>dTime</code> Faktor vernachlässigt.</p>
<pre><code class="hljs css language-C"><span class="hljs-comment">// Linienfolger mit 5 Sensoren        </span>

wertLinie = <span class="hljs-number">2000</span>                          <span class="hljs-comment">// Sollwert (Sensorwert genau über der Linie)</span>
kp        = <span class="hljs-number">1</span>                             <span class="hljs-comment">// Proportional-Faktor</span>
ki        = <span class="hljs-number">0.1</span>                           <span class="hljs-comment">// Integral-Faktor</span>
integral  = <span class="hljs-number">0</span>                             <span class="hljs-comment">// Startwert für Integral-Anteil</span>

wiederhole
    position   = leseLinie()              <span class="hljs-comment">// Position sei ein Wert zwischen  0 und 4000</span>
                                          <span class="hljs-comment">// Position = 2000 bedeutet, genau über der Linie</span>
    error      = position - wertLinie     <span class="hljs-comment">// Fehlerwert, Regeldifferenz</span>
    integral   = integral + error         <span class="hljs-comment">// Integral-Anteil </span>

    <span class="hljs-comment">// Proportional-Integral-Regler - Ändert die Geschwindigkeit                              </span>
    deltaSpeed = error * kp +  integral * ki   
                                
    leftSpeed  = leftSpeed - deltaSpeed   <span class="hljs-comment">// Drehzahl links bestimmen</span>
    rightSpeed = rightSpeed + deltaSpeed  <span class="hljs-comment">// Drehzahl rechts bestimmen</span>

    begrenze(leftSpeed)                   <span class="hljs-comment">// Drehzahl auf sinnvolle Werte begrenzen</span>
    begrenze(rightSpeed)
    setMotors(leftSpeed,rightSpeed)       <span class="hljs-comment">// Aktualisieren der Motordrehzahlen</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="differential-anteil"></a><a href="#differential-anteil" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Differential-Anteil</h2>
<p>Während der Integral-Anteil versucht lange bestehende Fehler aus der Vergangenheit zu korrigieren, wäre es schön, wenn der Regler auch mögliche Fehler in der Zukunft berücksichtigen würde. Das mag erstmal etwas komisch klingen, ist aber die Aufgabe des <strong>Differential-Anteils</strong>.</p>
<p>Nehmen wir als Beispiel an, der Roboter folgt perfekt einer Linie. Der Fehler ist sehr klein und der Regler funktioniert problemlos. Plötzlich erreicht der Roboter eine sehr scharfe Kurve. Der Fehler wäre Anfangs noch moderat, würde dann aber, weil der Roboter nicht schnell genug lenkt, sehr stark ansteigen. Oder mit anderen Worten, der Fehler würde einen sehr starken <strong>Anstieg</strong> aufweisen. Diesen starken Anstieg des Fehler versucht der Differential-Anteil des Reglers auszuwerten und als Regelgröße zu verwenden.</p>
<p>Der Differential-Anteil lässt sich mathematisch als Ableitungen des Fehlers berechnen. Alternativ, und mit dem Arduino viel einfacher zu bestimmen, kann der <a href="https://de.wikipedia.org/wiki/Differenzenquotient">Differenzenquotient</a> des Fehler berechnet werden. Für den Differenzenquotient gilt:
$$ m = \frac{y_1-y_0}{x_1-x_0}.$$
Wird diese Gleichung auf den Fehler \( e\) angewendet, ergibt sich ein einfacher Ausdrück für den Anstieg, bzw. die Änderung des Fehler \(e'\), also den gesuchten Differentialanteil <code>differential</code> des Reglers:
$$ e' = \frac{e_\text{alt}-e_\text{neu}}{\Delta t}.$$</p>
<p>Der Pseudocode für den Differential-Anteil könnte wie folgt aussehen:</p>
<pre><code class="hljs css language-c">differential = (error_alt - error) / dTime
</code></pre>
<p>Ähnlich wie beim Intergral-Anteil, kann auch beim Differential-Anteil auf die Multiplikation  mit der Zeitdifferenz  verzichtet werden, wenn die Sensoren immer im selben Zeitintervall ausgewertet werden. Der D-Anteil würde sich dannn zu einer einfachen Subtraktion vereinfachen.</p>
<pre><code class="hljs css language-c">differential = error_alt - error
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="pid"></a><a href="#pid" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>PID</h2>
<p>Führt man den P, I und D Anteil zusammen, erhält man den so genannten PID-Regler.</p>
<pre><code class="hljs css language-C"><span class="hljs-comment">// Linienfolger mit 5 Sensoren        </span>

wertLinie = <span class="hljs-number">2000</span>                          <span class="hljs-comment">// Sollwert (Sensorwert genau über der Linie)</span>
kp        = <span class="hljs-number">1</span>                             <span class="hljs-comment">// Proportional-Faktor</span>
ki        = <span class="hljs-number">0.1</span>                           <span class="hljs-comment">// Integral-Faktor</span>
kd        = <span class="hljs-number">0.1</span>
integral  = <span class="hljs-number">0</span>                             <span class="hljs-comment">// Startwert für Integral-Anteil</span>
error_alt = <span class="hljs-number">0</span>;


wiederhole
    position     = leseLinie()              <span class="hljs-comment">// Position sei ein Wert zwischen  0 und 4000</span>
                                            <span class="hljs-comment">// Position = 2000 bedeutet, genau über der Linie</span>
    error        = position - wertLinie     <span class="hljs-comment">// Fehlerwert, Regeldifferenz</span>
    integral     = integral + error         <span class="hljs-comment">// Integral-Anteil </span>
    differential = error_alt - error
    error_alt    = error

    <span class="hljs-comment">// PID-Regler - Ändert die Geschwindigkeit                              </span>
    deltaSpeed   = error * kp +  integral * ki + differential * kd  
                                
    leftSpeed    = leftSpeed - deltaSpeed   <span class="hljs-comment">// Drehzahl links bestimmen</span>
    rightSpeed   = rightSpeed + deltaSpeed  <span class="hljs-comment">// Drehzahl rechts bestimmen</span>

    begrenze(leftSpeed)                     <span class="hljs-comment">// Drehzahl auf sinnvolle Werte begrenzen</span>
    begrenze(rightSpeed)
    setMotors(leftSpeed,rightSpeed)         <span class="hljs-comment">// Aktualisieren der Motordrehzahlen</span>
</code></pre>
<ol>
<li>Alle Faktoren auf Null setzen.</li>
<li>Den P-Faktor  vergrößern, bis der Roboter bei nach einer Kurve zu oszillieren anfängt.</li>
<li>Erhöhe des D-Faktors, bis die Oszillationen verschwinden.</li>
<li>Schritte 2 und 3 wiederholen, bis eine Erhöhung des D-Faktors die Oszillation nicht mehr verschwinden lässt.</li>
<li>P- und D-Faktoren auf den letzten stabilen Wert setzen.</li>
<li>Erhöhen des I-Faktors, bis der Sollwerte (Linienmitte) mit der gewünschten Oszillation erreicht wird. In der Regel sollte der Roboter nicht oszillieren.</li>
</ol>
<p><a href="http://www.olliw.eu/storm32bgc-wiki/PID_online_simulator">PID-Simulator</a></p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/docs/botWeightedAverage"><span class="arrow-prev">← </span><span>Gewichteter Mittelwert</span></a><a class="docs-next button" href="/docs/botObstacle"><span>Suchen, Finden, Ausweichen</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#p-regler">P-Regler</a></li><li><a href="#integral-anteil">Integral-Anteil</a></li><li><a href="#differential-anteil">Differential-Anteil</a></li><li><a href="#pid">PID</a></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/" class="nav-home"><img src="/img/LogoSmallRed.svg" alt="Let&#x27;s rule the bots!  " width="66" height="58"/></a><div><a href="/blog">Blog</a><a href="https://www.youtube.com/watch?v=ARJ8cAGm6JE">HAL 9000</a></div><div></div></section><section class="copyright">Copyright © 2019 Stefan Warm</section></footer></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                
                apiKey: '8a8e0b313860e2fe23d0d40ec6dcd649',
                indexName: 'spacehal',
                inputSelector: '#search_input_react',
                algoliaOptions: {}
              });
            </script></body></html>