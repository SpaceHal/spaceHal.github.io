<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Linienfolger · Let&#x27;s rule the bots!  </title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="## Linienfolger mit einem IR Sensor (Kantenfolger)"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Linienfolger · Let&#x27;s rule the bots!  "/><meta property="og:type" content="website"/><meta property="og:url" content="https://spacehal.github.io/"/><meta property="og:description" content="## Linienfolger mit einem IR Sensor (Kantenfolger)"/><meta property="og:image" content="https://spacehal.github.io/img/undraw_online.svg"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://spacehal.github.io/img/undraw_tweetstorm.svg"/><link rel="shortcut icon" href="/img/LogoSmallRed.svg"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/railscasts.min.css"/><link rel="alternate" type="application/atom+xml" href="https://spacehal.github.io/blog/atom.xml" title="Let&#x27;s rule the bots!   Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://spacehal.github.io/blog/feed.xml" title="Let&#x27;s rule the bots!   Blog RSS Feed"/><script>
              (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
              (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
              m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
              })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

              ga('create', 'UA-144828360-1', 'auto');
              ga('send', 'pageview');
            </script><link rel="stylesheet" href="/css/code-block-buttons.css"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script><script type="text/javascript" src="/js/code-block-buttons.js"></script><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="/img/LogoSmallRed.svg" alt="Let&#x27;s rule the bots!  "/><h2 class="headerTitleWithLogo">Let&#x27;s rule the bots!  </h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/docs/helloworld" target="_self">Arduino</a></li><li class=""><a href="/docs/zumoInstallation" target="_self">Zumo</a></li><li class="siteNavGroupActive siteNavItemActive"><a href="/docs/botLineFollower" target="_self">Robotik</a></li><li class=""><a href="/docs/moreInfo" target="_self">Links</a></li><li class=""><a href="/blog/" target="_self">Blog</a></li><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Robotersteuerung</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">Robotersteuerung<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem navListItemActive"><a class="navItem" href="/docs/botLineFollower">Linienfolger</a></li><li class="navListItem"><a class="navItem" href="/docs/botObstacle">Hinderniserkennung</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 class="postHeaderTitle">Linienfolger</h1></header><article><div><span><h2><a class="anchor" aria-hidden="true" id="linienfolger-mit-einem-ir-sensor-kantenfolger"></a><a href="#linienfolger-mit-einem-ir-sensor-kantenfolger" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Linienfolger mit einem IR Sensor (Kantenfolger)</h2>
<p>Der einfachste Linienfolger ist, wenn man es genau nimmt, gar kein Linienfolger, sondern ein <strong>Kantenfolger</strong>. Besitzt der Roboter mindestens einen Bodensensor zum Unterscheiden von hellen und dunklen Untergründen, so kann damit bei einem genügend breitem Strich die Strichkante detektiert werden, und dieser gefolgt werden.</p>
<p><img src="../img/BotOnLine.png" alt="Line following robot" width=85% height=auto/></p>
<p>Das Grundprinzip des Kantenfolgers (Linienfolger mit nur einem Sensor) ist in der Abbildung dargestellt. Der IR-Sensor detektiert des vom Untergrund reflektierte Licht. In der Abbildung sind beispielhaft Zahlenwerte in rot angegeben. Bei einem weißen Untergrund wird viel und bei einem dunklen Untergrund wird wenig Licht detektiert.</p>
<h3><a class="anchor" aria-hidden="true" id="kantenfolger-algorithmus"></a><a href="#kantenfolger-algorithmus" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Kantenfolger-Algorithmus</h3>
<p>Für eine einfache Motorregelung zum Folgen der Linie, können drei verschieden Fälle unterschieden werden, welche mit einem Algorithmus überprüft werden müssen:</p>
<ul>
<li><strong>Fall A</strong>  Der Sensor ist im Wesentlichen neben der Linie und detektiert viel IR-Licht. Der Roboter sollte mehr nach links zur Linie fahren.</li>
<li><strong>Fall B</strong>  Der Sensor ist hauptsächlich über der Linie und detektiert wenig IR-Licht. Der Roboter sollte mehr nach rechts zur Linienkante fahren  muss</li>
<li><strong>Fall C</strong>  Der Sensor befindet sich genau zur Hälfte über der Linie und ist somit genau über der Kante. Der Roboter kann einfache geradeaus fahren.</li>
</ul>
<p>Ein Algorithmus zur Steuerung des Roboters (ohne Fall C) könnte folgendermaßen aussehen:</p>
<pre><code class="hljs"><span class="hljs-comment">// PSEUDO-CODE</span>
<span class="hljs-comment">// Einfacher Algorithmus zum Kantenfolgen mit nur einem IR-Sensor</span>

wertKante = <span class="hljs-number">600</span> <span class="hljs-comment">// muss angepasst werde</span>

wiederhole
    sensorWert = lese<span class="hljs-constructor">IRLicht()</span>
    <span class="hljs-keyword">if</span> ( sensorWert &gt; wertKante )
        fahre<span class="hljs-constructor">Links()</span> <span class="hljs-comment">// Fall A</span>
        
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( sensorWert &lt; wertKante )
        fahre<span class="hljs-constructor">Rechts()</span> <span class="hljs-comment">// Fall B</span>

</code></pre>
<h4><a class="anchor" aria-hidden="true" id="kalibrierung"></a><a href="#kalibrierung" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Kalibrierung</h4>
<p>Bleibt die Frage, wie der Sensorwerte für die Linienkante ermittelt wird, der Roboter also kalibriert werden kann. Der einfachste, wenn auch nicht genaueste Weg ist, z.B. mit Hilfe der seriellen Schnittstelle die Maximalwert und den Minimalwert des reflektieren IR Lichts für die Linie und die Fläche daneben zu bestimmen. Der Mittelwert aus beiden Werten sollte der Linienkante entsprechen und kann dann als Konstante in das Programm eingefügt werden.</p>
<blockquote>
<p>Der Kanten-Algorithmus funktioniert am besten, wenn der Roboter langsam fährt!</p>
</blockquote>
<h3><a class="anchor" aria-hidden="true" id="aufgaben-kantenfolger"></a><a href="#aufgaben-kantenfolger" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Aufgaben (Kantenfolger)</h3>
<div id="aufgabe">
<ol>
<li><p>Programmieren Sie den <strong>einfachen Kanten-Algorithmus</strong>. Passen Sie die Wert der Linienkannte an und schreiben Sie geeignete Methoden <code>fahreLinks()</code> und <code>fahreRechts()</code>.  <em><code>[Kantenfolger2Stufen.ino]</code></em></p></li>
<li><p>Schreiben Sie eine <strong>Kalibrierungsfunktion</strong>, welche (auf Knopfdruck) den Sensorwert für die Linienkante automatisch ermittelt. Lassen Sie hierfür den Roboter in beide Richtung automatisch über die Linie drehen und den Maximal- und Minimalwert des reflektierten Lichtes bestimmen. Aus beiden Werten den Sollwert der Linienkante. <em><code>[KantenfolgerKalibrierung.ino]</code></em></p></li>
<li><p><strong>Erweitern</strong> Sie den Algorithmus <strong>um den Fall C</strong>: <code>fahreGeradeaus()</code>.</p>
<p><em>Hinweis: Legen Sie einen geeigneten Wertebereich um den Sensorwert der Linienkante fest, bei dem der Roboter geradeaus fahren soll. Nutzen Sie hierfür die Variable  <code>wertToleranz</code></em>.  <em><code>[Kantenfolger3Stufen.ino]</code></em></p></li>
<li><p>Schreiben Sie ein neues Programm, welches den Kanten-Algorithmus um <strong>zwei weiter Stufen (halb links, halb rechts)</strong> erweitert. Geben Sie jedoch keine festen Sensorwerte für die verschiedenen Unterscheidungsfälle vor, sondern verwenden sie zwei verschiedene <strong>Toleranzbereiche</strong> und lassen sie die notwendigen Bereiche berechnen. Verwenden Sie außerdem die automatische Kalibrierungsfunktion aus Aufgabe 2. <em><code>[Kantenfolger5Stufen.ino]</code></em></p></li>
</ol>
</div>
<h3><a class="anchor" aria-hidden="true" id="proportional-regler-einfach"></a><a href="#proportional-regler-einfach" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Proportional-Regler (einfach)</h3>
<p>Der einfache Algorithmus zum Kantenfolgen funktioniert bei Linien und Abzweigung meistens ganz gut, lässt aber den Roboter die Linie entlangzappeln anstatt ihr geschmeidig zu folgen. Auch wird es mit dem einfache Algorithmus schwierig, dem Roboter bei Kreuzungen oder Abzweigung ein konkretes Verhalten zu programmieren.</p>
<p>Ein wesentlich besserer Ansatz ist der <strong>Proportional-Regler</strong> (P-Regler), bei dem es nicht nur drei verschiedene Unterscheidungsstufen mit drei verschiedenen Motordrehzahlen gibt, sondern für jeden Unterschied zwischen Sollwert (also)</p>
<p><img src="../img/GraphPRegler.png" alt="Proportional Control" width=75% height=auto/></p>
<p>Bei einem (Proportional-)Regler wird davon ausgegangen, dass ein System eine <strong>Sollgröße</strong> \( w \) einhalten soll. In unseren Fall ist die Sollgröße der vom Sensor zu erzielende Sensorwert der Linienkante. Weicht der <strong>Istwert</strong> \( y \), also der aktuell gemessene Sensorwert von der Soll Größe ab,so lässt sich die <strong>Regeldifferenz</strong> bzw. der <strong>Fehlerwert</strong> \( e \) leicht als Differenz aus Soll- und Istwert berechnen: \( e = w - y \). <strong>Das Ziel eines jeden Reglers ist, es diesen Fehlerwert so klein wie möglich zu halten.</strong> Im Fall des Kantenfolgers bedeutet das, dass der Roboter möglichst immer über der Kante bleibt.</p>
<p>Im Gegensatz zum 3-Stufen-Regler, bei dem für drei Bereiche drei feste Werte für die Motordrehzahl (und damit das Kurvenverhalten) festgelegt wurden, wird beim P-Regler die <strong>Abweichung der Motordrehzahl</strong> <code>deltaSpeed</code> von einer Normgröße <code>speed</code> gesteuert. Die aktuelle Motordrehzahl ergibt sich dann als Summe aus der Normgröße und dieser Abweichung. Wird die Geschwindigkeitsänderung <code>deltaSpeed</code> zur der Drehzahl des linken Rades addiert und von der Drehzahl des rechten Rades abgezogen, fährt der Roboter mit einer positiven Geschwindigkeitsänderung nach rechts und mit einer negativen Differenzgeschwindigkeit nach links:</p>
<pre><code class="hljs"><span class="hljs-comment">// PSEUDO-CODE </span>
<span class="hljs-comment">// speed &gt; 0: Rechtskurve</span>
<span class="hljs-comment">// speed &lt; 0: Linkskurve</span>

leftSpeed  = <span class="hljs-symbol">speed</span> + deltaSpeed  <span class="hljs-comment">// Drehzahl linkes Rad</span>
rightSpeed = <span class="hljs-symbol">speed</span> - deltaSpeed  <span class="hljs-comment">// Drehzahl rechtes Rad</span>
</code></pre>
<p>Die <strong>Geschwindigkeitsänderung</strong> der  Motordrehzahl \( \Delta \text{Speed} \)  lässt sich mit einem Proportionalitätsfaktor \( k_p \) aus dem Fehlerwert bestimmen:
$$ \Delta \text{Speed} = k_p \cdot e $$.</p>
<p>Die Wahl des Faktors \( k_p \) hat einen erheblichen Einfluss auf Fahrverhalten des Roboters. Ist \(k_p \) zu klein, wird der Roboter die Kante ganz schnell verlieren, ist  \(k_p \) zu groß, so fängt der Roboter wieder an zu wackeln. In diesem Fall spricht man auch von einem oszillierenden Verhalten.</p>
<h3><a class="anchor" aria-hidden="true" id="algorithmus-kantenfolger-mit-p-regler"></a><a href="#algorithmus-kantenfolger-mit-p-regler" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Algorithmus: Kantenfolger mit P-Regler</h3>
<p>Der Algorithmus für den Kantenfolger mit P-Regler könnte wie folgt aussehen:</p>
<pre><code class="hljs"><span class="hljs-comment">// PSEUDO-CODE</span>
<span class="hljs-comment">// Einfacher P-Regler für einen Kantenfolger</span>

wertKante = <span class="hljs-number">600</span>   <span class="hljs-comment">// Besser automatisch bestimmen.</span>
Kp        = <span class="hljs-number">0.3</span>   <span class="hljs-comment">// Proportionalitätsfaktor des P-Reglers. Ausprobieren, um den richtigen Wert zu finden.</span>
speed     = <span class="hljs-number">100</span>   <span class="hljs-comment">// Richtwert für die Motordrehzahl (Normwert)</span>

wiederhole
    sensorWert = lese<span class="hljs-constructor">IRLicht()</span>
    e = wertKante - sensorWert       <span class="hljs-comment">// Fehlerwert, Regeldifferenz</span>
    deltaSpeed = Kp<span class="hljs-operator"> * </span>e              <span class="hljs-comment">// Geschwindigkeitsänderung</span>
    leftSpeed  = speed + deltaSpeed  <span class="hljs-comment">// Drehzahl linkes Rad</span>
    rightSpeed = speed - deltaSpeed  <span class="hljs-comment">// Drehzahl rechtes Rad</span>
    set<span class="hljs-constructor">Motors(<span class="hljs-params">leftSpeed</span>,<span class="hljs-params">rightSpeed</span>)</span>  <span class="hljs-comment">// Aktualisieren der Motordrehzahlen</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="linienfolger-mit-mehreren-ir-sensoren"></a><a href="#linienfolger-mit-mehreren-ir-sensoren" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Linienfolger mit mehreren IR Sensoren</h2>
<h3><a class="anchor" aria-hidden="true" id="proportional-regler-komplex"></a><a href="#proportional-regler-komplex" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Proportional-Regler (komplex)</h3>
<p><img src="../img/BotOnLine3Sens.png" alt="Line following robot with 3 Sensors" width=80% height=auto/></p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-next button" href="/docs/botObstacle"><span>Hinderniserkennung</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#linienfolger-mit-einem-ir-sensor-kantenfolger">Linienfolger mit einem IR Sensor (Kantenfolger)</a><ul class="toc-headings"><li><a href="#kantenfolger-algorithmus">Kantenfolger-Algorithmus</a></li><li><a href="#aufgaben-kantenfolger">Aufgaben (Kantenfolger)</a></li><li><a href="#proportional-regler-einfach">Proportional-Regler (einfach)</a></li><li><a href="#algorithmus-kantenfolger-mit-p-regler">Algorithmus: Kantenfolger mit P-Regler</a></li></ul></li><li><a href="#linienfolger-mit-mehreren-ir-sensoren">Linienfolger mit mehreren IR Sensoren</a><ul class="toc-headings"><li><a href="#proportional-regler-komplex">Proportional-Regler (komplex)</a></li></ul></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/" class="nav-home"><img src="/img/LogoSmallRed.svg" alt="Let&#x27;s rule the bots!  " width="66" height="58"/></a><div><a href="/blog">Blog</a><a href="https://www.youtube.com/watch?v=ARJ8cAGm6JE">HAL 9000</a></div><div><a href="http://www.osztiem.de/home/startseite/">OSZ TIEM</a></div></section><section class="copyright">Copyright © 2019 Stefan Warm</section></footer></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                
                apiKey: '8a8e0b313860e2fe23d0d40ec6dcd649',
                indexName: 'spacehal',
                inputSelector: '#search_input_react',
                algoliaOptions: {}
              });
            </script></body></html>