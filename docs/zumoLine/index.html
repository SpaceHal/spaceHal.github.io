<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Die Liniensensoren · Let&#x27;s rule the bots!  </title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="## Einführung "/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Die Liniensensoren · Let&#x27;s rule the bots!  "/><meta property="og:type" content="website"/><meta property="og:url" content="https://spacehal.github.io/"/><meta property="og:description" content="## Einführung "/><meta property="og:image" content="https://spacehal.github.io/img/undraw_online.svg"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://spacehal.github.io/img/undraw_tweetstorm.svg"/><link rel="shortcut icon" href="/img/LogoSmallRed.svg"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css"/><link rel="alternate" type="application/atom+xml" href="https://spacehal.github.io/blog/atom.xml" title="Let&#x27;s rule the bots!   Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://spacehal.github.io/blog/feed.xml" title="Let&#x27;s rule the bots!   Blog RSS Feed"/><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Zilla+Slab:300,300i,500"/><link rel="stylesheet" href="/css/code-block-buttons.css"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script type="text/javascript" src="/js/load-mathjax.js" async=""></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script><script type="text/javascript" src="/js/code-block-buttons.js"></script><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="/img/LogoSmallRed.svg" alt="Let&#x27;s rule the bots!  "/><h2 class="headerTitleWithLogo">Let&#x27;s rule the bots!  </h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/docs/helloworld" target="_self">Arduino</a></li><li class=""><a href="/docs/botEdgeFollower" target="_self">Robotik</a></li><li class="siteNavGroupActive"><a href="/docs/zumoInstallation" target="_self">Zumo</a></li><li class=""><a href="/docs/moreInfo" target="_self">Links</a></li><li class=""><a href="/blog/" target="_self">Blog</a></li><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Zumo 32u4 Referenz</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">Zumo Grundfunktionen<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/zumoInstallation">Installation</a></li><li class="navListItem"><a class="navItem" href="/docs/zumoExampleMotorButton">Getting Started</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">Zumo 32u4 Referenz<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/zumoBasics">LEDs</a></li><li class="navListItem"><a class="navItem" href="/docs/zumoButtons">Taster</a></li><li class="navListItem"><a class="navItem" href="/docs/zumoMotors">Motoren</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/docs/zumoLine">Liniensensoren</a></li><li class="navListItem"><a class="navItem" href="/docs/zumoProxy">Näherungssensoren</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 id="__docusaurus" class="postHeaderTitle">Die Liniensensoren</h1></header><article><div><span><h2><a class="anchor" aria-hidden="true" id="einführung"></a><a href="#einführung" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Einführung</h2>
<p>Der Zumo32u4 hat fünf unabhängige IR-Bodensensoren, welche Linien oder auch Abgründe detektieren können. Die Sensoren befinden sich auf der Unterseite des Roboters, direkt hinter dem Metallschild.</p>
<p><img src="../img/ZumoLineDown.jpg" alt="Liniensensoren des Zumo" width=500px height=auto/></p>
<p>Ein einzelner <a href="https://www.pololu.com/docs/0J13/all#2">Bodensensor</a> bestehen aus einer Reihenschaltung eines <a href="https://www.pololu.com/file/0J117/QRE1113GR.pdf">Fototransistors</a> (welcher vereinfacht als lichtabhängiger Widerstand angesehen werden kann) und eines Kondensators. Ist der Kondensator aufgeladen, so hängt die Entladekurve vom Fototransistor und somit vom detektierten IR-Licht ab. Wird mit dem Mikrocontroller die Entladezeit des Kondensators gemessen, so kann damit die Menge des detektierten IR-Lichtes bestimmt werden.</p>
<p>Die Klasse <code>Zumo32U4LineSensors</code> stellt alle notwendigen Methoden zum Konfigurieren, Auslesen und Weiterverabeiten der 5 IR-Bodensensoren bereit. Sie ist in der Bibliothek des Zumo 32u4 integriert und wird durch den <code>include</code> Befehl in das Programm eingebunden.</p>
<pre><code class="hljs css language-Arduino"><span class="hljs-meta">#inlcude <span class="hljs-meta-string">&lt;Zumo32U4.h&gt;</span></span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="konfigurieren"></a><a href="#konfigurieren" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Konfigurieren</h2>
<h3><a class="anchor" aria-hidden="true" id="void-initthreesensors"></a><a href="#void-initthreesensors" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>void initThreeSensors()</code></h3>
<p><code>void initThreeSensors(uint8_t emitterPin = SENSOR_LEDON)</code></p>
<p>Initialisiert und konfiguriert das Liniensensor-Objekt so, dass <strong>drei Sensoren</strong> (die beiden äußeren und der mittlere) verwendet werden. Kann verwendet werden, wenn auch alle drei Näherungssensoren genutzt werden.</p>
<h3><a class="anchor" aria-hidden="true" id="void-initfivesensors"></a><a href="#void-initfivesensors" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>void initFiveSensors()</code></h3>
<p><code>void initFiveSensors(uint8_t emitterPin = SENSOR_LEDON)</code></p>
<p>Initialisiert und konfiguriert das Liniensensor-Objekt so, dass <strong>alle fünf Sensoren</strong> verwendet werden. Funktioniert nur, wenn die seitlichen Näherungssensoren deaktiviert wurden. Korrekte Jumper-Einstellung an der Platine der Liniensensoren beachten.</p>
<h4><a class="anchor" aria-hidden="true" id="beispiel"></a><a href="#beispiel" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Beispiel</h4>
<pre><code class="hljs css language-Arduino"><span class="hljs-meta">#inlcude <span class="hljs-meta-string">&lt;Zumo32U4.h&gt;</span></span>

Zumo32U4LineSensors lineSensors;    <span class="hljs-comment">// Liniensensor-Objekt</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setup</span><span class="hljs-params">()</span>
</span>{
    lineSensors.initFiveSensors();  
}
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="void-init"></a><a href="#void-init" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>void init(...)</code></h3>
<p><code>void init (uint8_t *pins, uint8_t numSensors, uint16_t timeout = 2000, uint8_t emitterPin = SENSOR_LEDON )</code></p>
<p>Initialisiert das Liniensensor-Objekt so, dass es einen benutzerdefinierten Satz von <code>pins</code> verwendet. Meistens sollte die Konfiguration mit  <code>void initThreeSensors()</code> oder <code>void initFiveSensors()</code> ausreichen.</p>
<ul>
<li><p>Das Array <code>pins</code> enthält die Arduino-Pin-Nummer für jeden Sensor.</p></li>
<li><p><code>numSensors</code> gibt die Länge des Arrays <code>pins</code> an (d.h. die Anzahl der verwendeten Linien-Sensoren).</p></li>
<li><p><code>timeout</code> gibt die Zeitspanne in Mikrosekunden an, nach welcher der Sensor die Fläche als vollständig schwarz betrachtet. Das heißt, wenn die Impulslänge für einen Pin die Zeitüberschreitung überschreitet, wird das Impuls-Timing gestoppt und der Messwert für diesen Pin wird als volles Schwarz betrachtet. Es wird empfohlen, dass der Timeout zwischen 1000 und 3000 us eingestellt wird, abhängig vom Bodenabstand der Sensoren und der Umgebungsbeleuchtung. Die Verwendung von Timeout ermöglicht es, die Dauer eines Sensorlesezyklus zu verkürzen und gleichzeitig nützliche analoge Messungen des Reflexionsgrades beizubehalten.</p></li>
<li><p><code>emitterPin</code> ist der Arduino-Pin, der die IR-LEDs Liniensensoren steuert.</p></li>
</ul>
<h4><a class="anchor" aria-hidden="true" id="beispiel-1"></a><a href="#beispiel-1" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Beispiel</h4>
<p>Initialisieren der drei mittleren IR Sensoren.</p>
<pre><code class="hljs css language-Arduino"><span class="hljs-meta">#inlcude <span class="hljs-meta-string">&lt;Zumo32U4.h&gt;</span></span>

Zumo32U4LineSensors lineSensors;                            <span class="hljs-comment">// Liniensensor-Objekt</span>

short pins[] = {SENSOR_DOWN2, SENSOR_DOWN3, SENSOR_DOWN4}; <span class="hljs-comment">// Array mit Sensor-Pins</span>
lineSensors.init(pins, <span class="hljs-keyword">sizeof</span>(pins), <span class="hljs-number">2000</span>, SENSOR_LEDON);  <span class="hljs-comment">// Initialisierung der Sensoren mit dem vorher definiertem Array </span>
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="void-calibrate"></a><a href="#void-calibrate" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>void calibrate()</code></h3>
<p><code>void calibrate(unsigned char readMode = QTR_EMITTERS_ON)</code></p>
<p>Ließt die Sensorwerte für ein Kalibrierung. Die beim wiederholden aufrufen der Methode ermittelten Maximal- und Minimalwerte werden für jeden Sensor einzeln abgespeichert und bei der Methode <code>readCalibrated()</code> genutzt. Auf die Kalibrierungsdaten (Minimal- und Maximalwerte der Sensore) kann mit den Pointern <code>calibratedMinimumOn</code>, <code>calibratedMaximumOn</code> und <code>calibratedMinimumOff</code>, <code>calibratedMaximumOff</code> zugegriffen werden. Dieser Pointer zeigen auf Arrays mit der Länge <code>numSensors</code>, wie es bei die Initialisierung angegeben worden ist.</p>
<p>Die Kalibrierungsdaten werden von den Methoden <a href="#void-readcalibrated#"><code>readCalibrated()</code></a> und <a href="#int-readline"><code>readLine</code>()</a> verwendet.</p>
<h4><a class="anchor" aria-hidden="true" id="beispiel-2"></a><a href="#beispiel-2" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Beispiel</h4>
<pre><code class="hljs css language-Arduino"><span class="hljs-comment">// Drehen des Roboters um +90°, -180° und abschließend +90° zum Kalibrieren der Liniensensoren</span>

<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">120</span>; i++)
  {
    <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">30</span> &amp;&amp; i &lt;= <span class="hljs-number">90</span>)
    {
      motors.setSpeeds(<span class="hljs-number">-200</span>, <span class="hljs-number">200</span>);
    }
    <span class="hljs-keyword">else</span>
    {
      motors.setSpeeds(<span class="hljs-number">200</span>, <span class="hljs-number">-200</span>);
    }
    lineSensors.calibrate();  <span class="hljs-comment">// Kalibrierungsmethode</span>
  }
  motors.setSpeeds(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
}
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="messen"></a><a href="#messen" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Messen</h2>
<h3><a class="anchor" aria-hidden="true" id="void-read"></a><a href="#void-read" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>void read(...)</code></h3>
<p><code>void read(unsigned int *sensor_values, unsigned char readMode=QTR_EMITTERS_ON)</code></p>
<p>Liest die rohen, unkalibrierten Sensorwerte in einen Array <code>sensor_values</code>. Es <strong>muss</strong> Platz für so viele Werte vorhanden sein, wie bei der Initialisierung an Sensoren angegeben wurden.
Die zurückgegebenen Werte sind ein Maß für den Reflexionsgrad in abstrakten Einheiten, wobei höhere Werte einem niedrigeren Reflexionsgrad entsprechen (z.B. eine schwarze Fläche oder ein Hohlraum).</p>
<h4><a class="anchor" aria-hidden="true" id="beispiel-3"></a><a href="#beispiel-3" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Beispiel</h4>
<pre><code class="hljs css language-Arduino">Zumo32U4LineSensors lineSensors;       <span class="hljs-comment">// Liniensensor-Objekt</span>

<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> lineSensorValues[<span class="hljs-number">3</span>];      <span class="hljs-comment">// Array für drei Sensorwerte</span>
lineSensors.<span class="hljs-built_in">read</span>(lineSensorValues);    <span class="hljs-comment">// Array für die Sensorwerte wird überschrieben</span>
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="void-readcalibrated"></a><a href="#void-readcalibrated" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>void readCalibrated(...)</code></h3>
<p><code>void readCalibrated(unsigned int *sensor_values, unsigned char readMode=QTR_EMITTERS_ON)</code></p>
<p>Liefert Werte, die auf einen Wert zwischen 0 und 1000 kalibriert sind, wobei 0 dem von <a href="#void-calibrate"><code>void calibrate()</code></a> gelesenen Minimalwert entspricht und 1000 dem Maximalwert entspricht.  Die Kalibrierungswerte werden für jeden Sensor separat gespeichert, so dass Unterschiede in den Sensoren automatisch berücksichtigt werden. Vor dem Aufruf der Methode sollte immer eine Kalibrierung mit <a href="#void-calibrate"><code>void calibrate()</code></a> durchgeführt werden.</p>
<h4><a class="anchor" aria-hidden="true" id="beispiel-4"></a><a href="#beispiel-4" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Beispiel</h4>
<pre><code class="hljs css language-Arduino"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NUM_SENSORS 3</span>
Zumo32U4LineSensors lineSensors;              <span class="hljs-comment">// Liniensensor-Objekt</span>

<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> lineSensorValues[NUM_SENSORS];   <span class="hljs-comment">// Array für die Sensorwerte</span>
lineSensors.readCalibrated(lineSensorValues); <span class="hljs-comment">// Array für die Sensorwerte wird überschrieben</span>
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="int-readline"></a><a href="#int-readline" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>int readLine(...)</code></h3>
<p><code>int readLine(unsigned int *sensor_values, unsigned char readMode=QTR_EMITTERS_ON, unsigned char white_line=0)</code></p>
<p>Funktioniert wie <code>readCalibrated()</code>, gibt aber auch eine geschätzte Position des Roboters in Bezug auf eine Linie zurück. Die Schätzung erfolgt unter Verwendung eines <a href="https://de.wikipedia.org/wiki/Gewichtung">gewichteten Mittelwerts</a>, welcher die Sensorwerte mit Vielfachen von 1000 multipliziert, so dass ein Rückgabewert von 0 anzeigt, dass die Zeile direkt unter Sensor 0 liegt, ein Rückgabewert von 1000 zeigt an, dass die Zeile direkt unter Sensor 1 liegt, 2000 zeigt an, dass sie unter Sensor 2000 liegt, usw.  Zwischenwerte zeigen an, dass sich die Linie zwischen zwei Sensoren befindet. Die Formel lautet : $$ \frac{0\cdot x_0 + 1000\cdot x_1 + 2000 \cdot x_2 +\cdots}{x_0 + x_1 + x_2 + \cdots} $$</p>
<p>Standardmäßig geht diese Funktion von einer dunklen Linie (hohe Werte) aus, die von Weiß (niedrige Werte) umgeben ist.  Wenn die verwendete Linie hell auf Schwarz ist, setzen Sie das optionale zweite Argument <code>white_line</code> auf <code>true</code>.  In diesem Fall wird jeder Sensorwert vor der Mittelung durch (1000 - Wert) ersetzt.</p>
<h4><a class="anchor" aria-hidden="true" id="beispiel-5"></a><a href="#beispiel-5" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Beispiel</h4>
<pre><code class="hljs css language-Arduino"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NUM_SENSORS 5</span>
Zumo32U4LineSensors lineSensors;              <span class="hljs-comment">// Liniensensor-Objekt</span>

<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> lineSensorValues[NUM_SENSORS];   <span class="hljs-comment">// Array für die Sensorwerte</span>
<span class="hljs-keyword">int</span> <span class="hljs-built_in">position</span> = lineSensors.readLine(lineSensorValues);
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="beispiel-für-die-bestimmung-der-linienposition"></a><a href="#beispiel-für-die-bestimmung-der-linienposition" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Beispiel für die Bestimmung der Linienposition</h2>
<pre><code class="hljs css language-Arduino"><span class="hljs-comment">/*
   Liniensensor-Demo mit alle fünf Boden Sensoren
*/</span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;Zumo32U4.h&gt;</span></span>

Zumo32U4LineSensors lineSensors;
Zumo32U4ButtonA buttonA;
Zumo32U4Motors motors;
Zumo32U4LCD lcd;


<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NUM_SENSORS 5                       <span class="hljs-comment">// Anzahl der verwendeten Sensoren</span></span>
<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> lineSensorValues[NUM_SENSORS]; <span class="hljs-comment">// Array für die Sensorwerte</span>

<span class="hljs-keyword">int</span> timeStamp = <span class="hljs-number">0</span>;

<span class="hljs-comment">// Eine Sekunde warten und dann beginnen mit der Kalibirierung der Bodensensoren</span>
<span class="hljs-comment">// durch automatisches Drehen des Roboters um etwa -90, +180, -90 Grad.</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">calibrateSensors</span><span class="hljs-params">()</span>
</span>{
  lcd.<span class="hljs-built_in">clear</span>();
  lcd.<span class="hljs-built_in">print</span>(F(<span class="hljs-string">"Calib ..."</span>));
  <span class="hljs-built_in">delay</span>(<span class="hljs-number">1000</span>);

  <span class="hljs-comment">// Kalibirierungsschleife: Roboter dreht sich und nimmt 120 Messwerte auf</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">120</span>; i++)
  {
    <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">30</span> &amp;&amp; i &lt;= <span class="hljs-number">90</span>){
      motors.setSpeeds(<span class="hljs-number">-200</span>, <span class="hljs-number">200</span>);
    }
    <span class="hljs-keyword">else</span>{
      motors.setSpeeds(<span class="hljs-number">200</span>, <span class="hljs-number">-200</span>);
    } 

    lineSensors.calibrate();  <span class="hljs-comment">// Sensoren auswerten und kalibrieren</span>
  }
  motors.setSpeeds(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
  lcd.<span class="hljs-built_in">clear</span>();
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setup</span><span class="hljs-params">()</span> </span>{
  lineSensors.initFiveSensors();    <span class="hljs-comment">// Bodensensoren initialisieren</span>

  <span class="hljs-comment">// "Welcome"-Anzeige auf dem Display</span>
  lcd.<span class="hljs-built_in">clear</span>();
  lcd.gotoXY(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>); lcd.<span class="hljs-built_in">print</span>(F(<span class="hljs-string">"LineDemo"</span>));
  lcd.gotoXY(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>); lcd.<span class="hljs-built_in">print</span>(F(<span class="hljs-string">"-&gt; A"</span>));
  buttonA.waitForPress();
  lcd.<span class="hljs-built_in">clear</span>();

  calibrateSensors();
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">loop</span><span class="hljs-params">()</span> </span>{
  
  <span class="hljs-keyword">int</span> updateTime = <span class="hljs-number">333</span>;

  <span class="hljs-comment">// alle 0.33 ms auswerten der Sensoren und aktualisieren des Display</span>
  <span class="hljs-keyword">if</span> ( (<span class="hljs-built_in">millis</span>() - timeStamp) &gt; updateTime){
    <span class="hljs-keyword">int</span> <span class="hljs-built_in">position</span> = lineSensors.readLine(lineSensorValues);
    lcd.gotoXY(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);
    lcd.<span class="hljs-built_in">print</span>(<span class="hljs-built_in">position</span>);
    lcd.<span class="hljs-built_in">print</span>(F(<span class="hljs-string">"   "</span>));  
  }
}
</code></pre>
<p><a href="botLineFollower">Linienfolger</a></p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/docs/zumoMotors"><span class="arrow-prev">← </span><span>Motoren</span></a><a class="docs-next button" href="/docs/zumoProxy"><span>Näherungssensoren</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#einführung">Einführung</a></li><li><a href="#konfigurieren">Konfigurieren</a><ul class="toc-headings"><li><a href="#void-initthreesensors"><code>void initThreeSensors()</code></a></li><li><a href="#void-initfivesensors"><code>void initFiveSensors()</code></a></li><li><a href="#void-init"><code>void init(...)</code></a></li><li><a href="#void-calibrate"><code>void calibrate()</code></a></li></ul></li><li><a href="#messen">Messen</a><ul class="toc-headings"><li><a href="#void-read"><code>void read(...)</code></a></li><li><a href="#void-readcalibrated"><code>void readCalibrated(...)</code></a></li><li><a href="#int-readline"><code>int readLine(...)</code></a></li></ul></li><li><a href="#beispiel-für-die-bestimmung-der-linienposition">Beispiel für die Bestimmung der Linienposition</a></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/" class="nav-home"><img src="/img/LogoSmallRed.svg" alt="Let&#x27;s rule the bots!  " width="66" height="58"/></a><div><a href="/blog">Blog</a><a href="https://www.youtube.com/watch?v=ARJ8cAGm6JE">HAL 9000</a></div><div></div></section><section class="copyright">Copyright © 2020 Stefan Warm</section></footer></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                
                apiKey: '8a8e0b313860e2fe23d0d40ec6dcd649',
                indexName: 'spacehal',
                inputSelector: '#search_input_react',
                algoliaOptions: {}
              });
            </script></body></html>