<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>3-Stufen-Regler für einen Kantenfolger · Let&#x27;s rule the bots!  </title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="Der einfachste Linienfolger ist, wenn man es genau nimmt, gar kein Linienfolger, sondern ein **Kantenfolger**. Besitzt der Roboter **einen** Bodensensor zum Unterscheiden von hellen und dunklen Untergründen, so kann damit bei einem genügend breitem Strich die Strichkante detektiert werden, und dieser gefolgt werden. "/><meta name="docsearch:language" content="en"/><meta property="og:title" content="3-Stufen-Regler für einen Kantenfolger · Let&#x27;s rule the bots!  "/><meta property="og:type" content="website"/><meta property="og:url" content="https://spacehal.github.io/"/><meta property="og:description" content="Der einfachste Linienfolger ist, wenn man es genau nimmt, gar kein Linienfolger, sondern ein **Kantenfolger**. Besitzt der Roboter **einen** Bodensensor zum Unterscheiden von hellen und dunklen Untergründen, so kann damit bei einem genügend breitem Strich die Strichkante detektiert werden, und dieser gefolgt werden. "/><meta property="og:image" content="https://spacehal.github.io/img/undraw_online.svg"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://spacehal.github.io/img/undraw_tweetstorm.svg"/><link rel="shortcut icon" href="/img/LogoSmallRed.svg"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/agate.min.css"/><link rel="alternate" type="application/atom+xml" href="https://spacehal.github.io/blog/atom.xml" title="Let&#x27;s rule the bots!   Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://spacehal.github.io/blog/feed.xml" title="Let&#x27;s rule the bots!   Blog RSS Feed"/><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Zilla+Slab:300,300i,500,600"/><link rel="stylesheet" href="/css/code-block-buttons.css"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML"></script><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="/img/LogoSmallRed.svg" alt="Let&#x27;s rule the bots!  "/><h2 class="headerTitleWithLogo">Let&#x27;s rule the bots!  </h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/docs/helloworld" target="_self">Arduino</a></li><li class="siteNavGroupActive siteNavItemActive"><a href="/docs/botEdgeFollower" target="_self">Robotik</a></li><li class=""><a href="/docs/zumoInstallation" target="_self">Zumo</a></li><li class=""><a href="/docs/moreInfo" target="_self">Links</a></li><li class=""><a href="/blog/" target="_self">Blog</a></li><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Linienfolger</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">Linienfolger<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem navListItemActive"><a class="navItem" href="/docs/botEdgeFollower">3-Stufen-Regler (Kantenfolger)</a></li><li class="navListItem"><a class="navItem" href="/docs/botEdge_P_Control">P-Regler (Kantenfolger)</a></li><li class="navListItem"><a class="navItem" href="/docs/botWeightedAverage">Gewichteter Mittelwert</a></li><li class="navListItem"><a class="navItem" href="/docs/botLineFollower">PID-Regler</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">Hindernisserkennung<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/botObstacle">Suchen, Finden, Ausweichen</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 class="postHeaderTitle">3-Stufen-Regler für einen Kantenfolger</h1></header><article><div><span><p>Der einfachste Linienfolger ist, wenn man es genau nimmt, gar kein Linienfolger, sondern ein <strong>Kantenfolger</strong>. Besitzt der Roboter <strong>einen</strong> Bodensensor zum Unterscheiden von hellen und dunklen Untergründen, so kann damit bei einem genügend breitem Strich die Strichkante detektiert werden, und dieser gefolgt werden.</p>
<p><img src="../img/BotOnLine.png" alt="Line following robot" width=600px height=auto/></p>
<p>Das Grundprinzip des Kantenfolgers (Linienfolger mit nur einem Sensor) ist in der Abbildung dargestellt. Der IR-Sensor detektiert des vom Untergrund reflektierte Licht. In der Abbildung sind beispielhaft Zahlenwerte in rot angegeben. Bei einem weißen Untergrund wird viel und bei einem dunklen Untergrund wird wenig Licht detektiert.</p>
<h2><a class="anchor" aria-hidden="true" id="3-stufen-algorithmus"></a><a href="#3-stufen-algorithmus" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>3-Stufen-Algorithmus</h2>
<p>Für eine einfache Motorregelung zum Folgen der Linie, können drei verschieden Fälle unterschieden werden, welche mit einem Algorithmus überprüft werden müssen:</p>
<ul>
<li><strong>Fall A</strong>  Der Sensor ist im Wesentlichen neben der Linie und detektiert viel IR-Licht. Der Roboter sollte mehr nach links zur Linie fahren.</li>
<li><strong>Fall B</strong>  Der Sensor ist hauptsächlich über der Linie und detektiert wenig IR-Licht. Der Roboter sollte mehr nach rechts zur Linienkante fahren.</li>
<li><strong>Fall C</strong>  Der Sensor befindet sich genau zur Hälfte über der Linie und ist somit genau über der Kante. Der Roboter kann einfache geradeaus fahren.</li>
</ul>
<p>Ein Algorithmus zur Steuerung des Roboters (ohne Fall C) könnte folgendermaßen aussehen:</p>
<pre><code class="hljs"><span class="hljs-comment">// PSEUDO-CODE</span>
<span class="hljs-comment">// Einfacher Algorithmus zum Kantenfolgen mit nur einem IR-Sensor</span>

wertKante = <span class="hljs-number">600</span> <span class="hljs-comment">// muss angepasst werde</span>

wiederhole
    sensorWert = lese<span class="hljs-constructor">IRLicht()</span>
    <span class="hljs-keyword">if</span> ( sensorWert &gt; wertKante )
        fahre<span class="hljs-constructor">Links()</span> <span class="hljs-comment">// Fall A</span>
        
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( sensorWert &lt; wertKante )
        fahre<span class="hljs-constructor">Rechts()</span> <span class="hljs-comment">// Fall B</span>

</code></pre>
<h3><a class="anchor" aria-hidden="true" id="kalibrierung"></a><a href="#kalibrierung" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Kalibrierung</h3>
<p>Bleibt die Frage, wie der Sensorwerte für die Linienkante ermittelt wird, der Roboter also kalibriert werden kann. Der einfachste, wenn auch nicht genaueste Weg ist, z.B. mit Hilfe der seriellen Schnittstelle die Maximalwert und den Minimalwert des reflektieren IR Lichts für die Linie und die Fläche daneben zu bestimmen. Der Mittelwert aus beiden Werten sollte der Linienkante entsprechen und kann dann als Konstante in das Programm eingefügt werden.</p>
<blockquote>
<p>Der Kanten-Algorithmus funktioniert am besten, wenn der Roboter langsam fährt!</p>
</blockquote>
<h3><a class="anchor" aria-hidden="true" id="aufgaben-kantenfolger"></a><a href="#aufgaben-kantenfolger" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Aufgaben (Kantenfolger)</h3>
<div id="aufgabe">
<ol>
<li><p>Programmieren Sie den <strong>einfachen Kanten-Algorithmus</strong>. Passen Sie die Wert der Linienkannte an und schreiben Sie geeignete Methoden <code>fahreLinks()</code> und <code>fahreRechts()</code>.  <em><code>[Kantenfolger2Stufen.ino]</code></em></p></li>
<li><p>Schreiben Sie eine <strong>Kalibrierungsfunktion</strong>, welche (auf Knopfdruck) den Sensorwert für die Linienkante automatisch ermittelt. Lassen Sie hierfür den Roboter in beide Richtung automatisch über die Linie drehen und den Maximal- und Minimalwert des reflektierten Lichtes bestimmen. Aus beiden Werten den Sollwert der Linienkante. <em><code>[KantenfolgerKalibrierung.ino]</code></em></p></li>
<li><p><strong>Erweitern</strong> Sie den Algorithmus <strong>um den Fall C</strong>: <code>fahreGeradeaus()</code>.</p>
<p><em>Hinweis: Legen Sie einen geeigneten Wertebereich um den Sensorwert der Linienkante fest, bei dem der Roboter geradeaus fahren soll. Nutzen Sie hierfür die Variable  <code>wertToleranz</code></em>.  <em><code>[Kantenfolger3Stufen.ino]</code></em></p></li>
<li><p>Schreiben Sie ein neues Programm, welches den Kanten-Algorithmus um <strong>zwei weitere Stufen (halb links, halb rechts)</strong> erweitert. Geben Sie jedoch keine festen Sensorwerte für die verschiedenen Unterscheidungsfälle vor, sondern verwenden sie zwei verschiedene <strong>Toleranzbereiche</strong> und lassen sie die notwendigen Bereiche berechnen. Verwenden Sie außerdem die automatische Kalibrierungsfunktion aus Aufgabe 2. <em><code>[Kantenfolger5Stufen.ino]</code></em></p></li>
</ol>
</div>
</span></div></article></div><div class="docs-prevnext"><a class="docs-next button" href="/docs/botEdge_P_Control"><span>P-Regler (Kantenfolger)</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#3-stufen-algorithmus">3-Stufen-Algorithmus</a><ul class="toc-headings"><li><a href="#kalibrierung">Kalibrierung</a></li><li><a href="#aufgaben-kantenfolger">Aufgaben (Kantenfolger)</a></li></ul></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/" class="nav-home"><img src="/img/LogoSmallRed.svg" alt="Let&#x27;s rule the bots!  " width="66" height="58"/></a><div><a href="/blog">Blog</a><a href="https://www.youtube.com/watch?v=ARJ8cAGm6JE">HAL 9000</a></div><div><a href="http://www.osztiem.de/home/startseite/">OSZ TIEM</a></div></section><section class="copyright">Copyright © 2019 Stefan Warm</section></footer></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                
                apiKey: '8a8e0b313860e2fe23d0d40ec6dcd649',
                indexName: 'spacehal',
                inputSelector: '#search_input_react',
                algoliaOptions: {}
              });
            </script></body></html>