<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Proportional-Regler für einen Kantenfolger · Let&#x27;s rule the bots!  </title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="Der einfache [3-Stufen Algorithmus](botEdgeFollower) zum Kantenfolgen funktioniert bei Linien und Abzweigung meistens ganz gut, lässt aber den Roboter die Linie entlangzappeln anstatt ihr geschmeidig zu folgen. Auch wird es mit dem einfache Algorithmus schwierig, dem Roboter bei Kreuzungen oder Abzweigung ein konkretes Verhalten zu programmieren. "/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Proportional-Regler für einen Kantenfolger · Let&#x27;s rule the bots!  "/><meta property="og:type" content="website"/><meta property="og:url" content="https://spacehal.github.io/"/><meta property="og:description" content="Der einfache [3-Stufen Algorithmus](botEdgeFollower) zum Kantenfolgen funktioniert bei Linien und Abzweigung meistens ganz gut, lässt aber den Roboter die Linie entlangzappeln anstatt ihr geschmeidig zu folgen. Auch wird es mit dem einfache Algorithmus schwierig, dem Roboter bei Kreuzungen oder Abzweigung ein konkretes Verhalten zu programmieren. "/><meta property="og:image" content="https://spacehal.github.io/img/undraw_online.svg"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://spacehal.github.io/img/undraw_tweetstorm.svg"/><link rel="shortcut icon" href="/img/LogoSmallRed.svg"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css"/><link rel="alternate" type="application/atom+xml" href="https://spacehal.github.io/blog/atom.xml" title="Let&#x27;s rule the bots!   Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://spacehal.github.io/blog/feed.xml" title="Let&#x27;s rule the bots!   Blog RSS Feed"/><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Zilla+Slab:300,300i,500"/><link rel="stylesheet" href="/css/code-block-buttons.css"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script type="text/javascript" src="/js/load-mathjax.js" async=""></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script><script type="text/javascript" src="/js/code-block-buttons.js"></script><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="/img/LogoSmallRed.svg" alt="Let&#x27;s rule the bots!  "/><h2 class="headerTitleWithLogo">Let&#x27;s rule the bots!  </h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/docs/helloworld" target="_self">Arduino</a></li><li class="siteNavGroupActive"><a href="/docs/botEdgeFollower" target="_self">Robotik</a></li><li class=""><a href="/docs/zumoInstallation" target="_self">Zumo</a></li><li class=""><a href="/docs/moreInfo" target="_self">Links</a></li><li class=""><a href="/blog/" target="_self">Blog</a></li><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Linienfolger</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">Linienfolger<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/botEdgeFollower">3-Stufen-Regler (Kantenfolger)</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/docs/botEdge_P_Control">P-Regler (Kantenfolger)</a></li><li class="navListItem"><a class="navItem" href="/docs/botWeightedAverage">Gewichteter Mittelwert</a></li><li class="navListItem"><a class="navItem" href="/docs/botLineFollower">PID-Regler</a></li><li class="navListItem"><a class="navItem" href="/docs/botIntersection">Erkennen von Kreuzungen</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">Hindernisserkennung<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/botObstacle">Suchen, Finden, Ausweichen</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 id="__docusaurus" class="postHeaderTitle">Proportional-Regler für einen Kantenfolger</h1></header><article><div><span><p>Der einfache <a href="botEdgeFollower">3-Stufen Algorithmus</a> zum Kantenfolgen funktioniert bei Linien und Abzweigung meistens ganz gut, lässt aber den Roboter die Linie entlangzappeln anstatt ihr geschmeidig zu folgen. Auch wird es mit dem einfache Algorithmus schwierig, dem Roboter bei Kreuzungen oder Abzweigung ein konkretes Verhalten zu programmieren.</p>
<p>Ein wesentlich besserer Ansatz ist der <strong>Proportional-Regler</strong> (P-Regler), bei dem es nicht nur drei verschiedene Unterscheidungsstufen mit drei verschiedenen Motordrehzahlen gibt, sondern für jeden Unterschied zwischen Sollwert (also)</p>
<p><img src="../img/GraphPRegler.png" alt="Proportional Control" width=550px height=auto/></p>
<p>Bei einem (Proportional-)Regler wird davon ausgegangen, dass ein System eine <strong>Sollgröße</strong> \( w \) einhalten soll. In unseren Fall ist die Sollgröße der vom Sensor zu erzielende Sensorwert der Linienkante. Weicht der <strong>Istwert</strong> \( y \), also der aktuell gemessene Sensorwert von der Soll Größe ab,so lässt sich die <strong>Regeldifferenz</strong> bzw. der <strong>Fehlerwert</strong> \( e \) leicht als Differenz aus Soll- und Istwert berechnen: \( e = w - y \). <strong>Das Ziel eines jeden Reglers ist, es diesen Fehlerwert so klein wie möglich zu halten.</strong> Im Fall des Kantenfolgers bedeutet das, dass der Roboter möglichst immer über der Kante bleibt.</p>
<p>Im Gegensatz zum 3-Stufen-Regler, bei dem für drei Bereiche drei feste Werte für die Motordrehzahl (und damit das Kurvenverhalten) festgelegt wurden, wird beim P-Regler die <strong>Abweichung der Motordrehzahl</strong> <code>deltaSpeed</code> von einer Normgröße <code>speed</code> gesteuert. Die aktuelle Motordrehzahl ergibt sich dann als Summe aus der Normgröße und dieser Abweichung. Wird die Geschwindigkeitsänderung <code>deltaSpeed</code> zur der Drehzahl des linken Rades addiert und von der Drehzahl des rechten Rades abgezogen, fährt der Roboter mit einer positiven Geschwindigkeitsänderung nach rechts und mit einer negativen Differenzgeschwindigkeit nach links:</p>
<pre><code class="hljs"><span class="hljs-comment">// PSEUDO-CODE </span>
<span class="hljs-comment">// speed &gt; 0: Rechtskurve</span>
<span class="hljs-comment">// speed &lt; 0: Linkskurve</span>

leftSpeed  = <span class="hljs-symbol">speed</span> + deltaSpeed  <span class="hljs-comment">// Drehzahl linkes Rad</span>
rightSpeed = <span class="hljs-symbol">speed</span> - deltaSpeed  <span class="hljs-comment">// Drehzahl rechtes Rad</span>
</code></pre>
<p>Die <strong>Geschwindigkeitsänderung</strong> der  Motordrehzahl \( \Delta \text{Speed} \)  lässt sich mit einem Proportionalitätsfaktor \( k_p \) aus dem Fehlerwert bestimmen:
$$ \Delta \text{Speed} = k_p \cdot e $$.</p>
<h3><a class="anchor" aria-hidden="true" id="wahl-des-faktors--k_p-"></a><a href="#wahl-des-faktors--k_p-" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Wahl des Faktors \( k_p \)</h3>
<p>Die Wahl des Faktors \( k_p \) hat einen erheblichen Einfluss auf Fahrverhalten des Roboters.</p>
<ul>
<li>Ist \(k_p \) zu klein, wird der Fehler nicht schnell genug geändert und der Roboter wird bei einer Kurve ganz schnell die Kante verlieren. Der Fehler steigt also immer weiter an.</li>
<li>Ist  \(k_p \) jedoch zu groß gewählt, so fängt der Roboter an hin- und herzuschwingen. In diesem Fall spricht man auch von einem <strong>oszillierenden Verhalten</strong>. Diese Oszillationsbewegungen entstehen, weil auf relativ kleine Fehler mit einem zu starken Gegenlenken (also einem zu großen <code>deltaSpeed</code>) reagiert wird. Man kennt dieses Verhalten von Kindern, die Fahrrad fahren lernen. So lange wie sie noch unsicher sind, wackeln Sie stark mit dem Lenker um das Gleichgewicht zu halten. Erst mit etwas mehr Übung wird ihr Fahrverhalten ruhiger und das Schlingern des Rades nimmt ab.</li>
<li>Ähnlich wie bei dem 3-Stufenregler hat die Geschwindigkeit des Roboters einen großen Einfluss auf das Ergebnis des Reglers. Beginnen Sie am besten mit <strong>einer geringen Geschwindigkeit</strong>.</li>
</ul>
<h3><a class="anchor" aria-hidden="true" id="pseudocode-p-regler"></a><a href="#pseudocode-p-regler" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Pseudocode P-Regler</h3>
<p>Der Algorithmus für den Kantenfolger mit P-Regler könnte wie folgt aussehen:</p>
<pre><code class="hljs"><span class="hljs-comment">// PSEUDO-CODE</span>
<span class="hljs-comment">// Einfacher P-Regler für einen Kantenfolger</span>

wertKante = <span class="hljs-number">600</span>   <span class="hljs-comment">// Besser automatisch bestimmen.</span>
Kp        = <span class="hljs-number">0.3</span>   <span class="hljs-comment">// Proportionalitätsfaktor des P-Reglers. Ausprobieren, um den richtigen Wert zu finden.</span>
speed     = <span class="hljs-number">100</span>   <span class="hljs-comment">// Richtwert für die Motordrehzahl (Normwert)</span>

wiederhole
    sensorWert = lese<span class="hljs-constructor">IRLicht()</span>
    e = wertKante - sensorWert       <span class="hljs-comment">// Fehlerwert, Regeldifferenz</span>
    deltaSpeed = Kp<span class="hljs-operator"> * </span>e              <span class="hljs-comment">// Geschwindigkeitsänderung</span>
    leftSpeed  = speed + deltaSpeed  <span class="hljs-comment">// Drehzahl linkes Rad</span>
    rightSpeed = speed - deltaSpeed  <span class="hljs-comment">// Drehzahl rechtes Rad</span>
    begrenze(leftSpeed)              <span class="hljs-comment">// Werte dürfen nur in einem bestimmten ...</span>
    begrenze(rightSpeed)             <span class="hljs-comment">// Wertebereich liegen (z.B. 0 ... 127)</span>
    set<span class="hljs-constructor">Motors(<span class="hljs-params">leftSpeed</span>,<span class="hljs-params">rightSpeed</span>)</span>  <span class="hljs-comment">// Aktualisieren der Motordrehzahlen</span>
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="werte-begrenzen-mit-constrain"></a><a href="#werte-begrenzen-mit-constrain" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Werte begrenzen mit <code>constrain()</code></h3>
<p>In vielen Fällen ist es sinnvoll, die Werte von <code>leftSpeed</code> und <code>rightSpeed</code> zu begrenzen. Hierfür eignet sich die Arduino-Funktion:</p>
<p><code>wertC = constrain(wert,min,max)</code>,</p>
<p>welche den Eingabewert <code>wert</code> auf den angegebenen Minimal- <code>min</code> und Maximalwert <code>max</code> begrenzt. Hierbei gilt:</p>
<ul>
<li><code>wertC</code> = <code>wert</code>, wenn <code>wert</code> zwischen <code>min</code> und <code>max</code></li>
<li><code>wertC</code> = <code>min</code>, wenn  <code>wert</code> kleiner <code>min</code> ist</li>
<li><code>wertC</code> = <code>max</code>, wenn  <code>wert</code> größer <code>max</code> ist</li>
</ul>
<p><strong>Beispiel</strong></p>
<pre><code class="hljs css language-Arduino"><span class="hljs-comment">// Begrenzt leftSpeed auf Werte von 0 bis 255</span>
leftSpeed = <span class="hljs-built_in">constrain</span>(leftSpeed, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>); 
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="aufgaben-kantenfolger-p-regler"></a><a href="#aufgaben-kantenfolger-p-regler" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Aufgaben (Kantenfolger P-Regler)</h3>
<div id="aufgabe">
<ol>
<li>Programmieren Sie einen Kantenfolger mit <strong>P-Regler</strong>. Variieren Sie den Kp-Faktor und analysieren Sie dessen Einfluss auf das Verhalten des Roboters auf gerader Strecke und in Kurvenfahrten. Bei welchem Wert folgt der Roboter ohne zu schwingen einer <strong>geraden</strong> Linie? <em><code>[KantenfolgerPRegler.ino]</code></em></li>
</ol>
</div>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/docs/botEdgeFollower"><span class="arrow-prev">← </span><span>3-Stufen-Regler (Kantenfolger)</span></a><a class="docs-next button" href="/docs/botWeightedAverage"><span>Gewichteter Mittelwert</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/" class="nav-home"><img src="/img/LogoSmallRed.svg" alt="Let&#x27;s rule the bots!  " width="66" height="58"/></a><div><a href="/blog">Blog</a><a href="https://www.youtube.com/watch?v=ARJ8cAGm6JE">HAL 9000</a></div><div></div></section><section class="copyright">Copyright © 2019 Stefan Warm</section></footer></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                
                apiKey: '8a8e0b313860e2fe23d0d40ec6dcd649',
                indexName: 'spacehal',
                inputSelector: '#search_input_react',
                algoliaOptions: {}
              });
            </script></body></html>