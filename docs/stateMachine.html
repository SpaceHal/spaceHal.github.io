<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Endliche Automaten (Finite State Machine) · Let&#x27;s rule the bots!  </title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="Programme oder logische Systeme, welche eine **endliche** Anzahl verschiedener Zustände aufweisen und diese nach festgelegten Kriterien ändern sollen, können durch [endliche Automaten](https://de.wikipedia.org/wiki/Endlicher_Automat) (auch endliche Zustandsmaschine oder *finit state machine - FSM*) modelliert werden. Ein endlicher Automat soll ein Verhalten modellieren, welches auf einer endlichen Anzahl von **Zuständen**, **Aktionen** und **Zustandsübergängen** basiert. "/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Endliche Automaten (Finite State Machine) · Let&#x27;s rule the bots!  "/><meta property="og:type" content="website"/><meta property="og:url" content="https://spacehal.github.io/"/><meta property="og:description" content="Programme oder logische Systeme, welche eine **endliche** Anzahl verschiedener Zustände aufweisen und diese nach festgelegten Kriterien ändern sollen, können durch [endliche Automaten](https://de.wikipedia.org/wiki/Endlicher_Automat) (auch endliche Zustandsmaschine oder *finit state machine - FSM*) modelliert werden. Ein endlicher Automat soll ein Verhalten modellieren, welches auf einer endlichen Anzahl von **Zuständen**, **Aktionen** und **Zustandsübergängen** basiert. "/><meta property="og:image" content="https://spacehal.github.io/img/undraw_online.svg"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://spacehal.github.io/img/undraw_tweetstorm.svg"/><link rel="shortcut icon" href="/img/LogoSmallRed.svg"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css"/><link rel="alternate" type="application/atom+xml" href="https://spacehal.github.io/blog/atom.xml" title="Let&#x27;s rule the bots!   Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://spacehal.github.io/blog/feed.xml" title="Let&#x27;s rule the bots!   Blog RSS Feed"/><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Zilla+Slab:300,300i,500"/><link rel="stylesheet" href="/css/code-block-buttons.css"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script type="text/javascript" src="/js/load-mathjax.js" async=""></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script><script type="text/javascript" src="/js/code-block-buttons.js"></script><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="/img/LogoSmallRed.svg" alt="Let&#x27;s rule the bots!  "/><h2 class="headerTitleWithLogo">Let&#x27;s rule the bots!  </h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/docs/helloworld" target="_self">Arduino</a></li><li class=""><a href="/docs/botEdgeFollower" target="_self">Robotik</a></li><li class=""><a href="/docs/zumoInstallation" target="_self">Zumo</a></li><li class=""><a href="/docs/moreInfo" target="_self">Links</a></li><li class=""><a href="/blog/" target="_self">Blog</a></li><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Grundlagen</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">Grundlagen<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/helloworld">Hallo Welt</a></li><li class="navListItem"><a class="navItem" href="/docs/seriell">Serielle Schnittstelle</a></li><li class="navListItem"><a class="navItem" href="/docs/loopVariable">Variablen und Schleifen</a></li><li class="navListItem"><a class="navItem" href="/docs/input">Digitale Eingaben</a></li><li class="navListItem"><a class="navItem" href="/docs/millis">Zeitkritische Aufgaben</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/docs/stateMachine">Endliche Automaten</a></li><li class="navListItem"><a class="navItem" href="/docs/debounce">Entprellen</a></li><li class="navListItem"><a class="navItem" href="/docs/pwm">PWM Signal</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">Motorsteuerung<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/motorHBridge">Motor mit H-Brücke</a></li><li class="navListItem"><a class="navItem" href="/docs/motorPWM">Motordrehzahl</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 id="__docusaurus" class="postHeaderTitle">Endliche Automaten (Finite State Machine)</h1></header><article><div><span><p>Programme oder logische Systeme, welche eine <strong>endliche</strong> Anzahl verschiedener Zustände aufweisen und diese nach festgelegten Kriterien ändern sollen, können durch <a href="https://de.wikipedia.org/wiki/Endlicher_Automat">endliche Automaten</a> (auch endliche Zustandsmaschine oder <em>finit state machine - FSM</em>) modelliert werden. Ein endlicher Automat soll ein Verhalten modellieren, welches auf einer endlichen Anzahl von <strong>Zuständen</strong>, <strong>Aktionen</strong> und <strong>Zustandsübergängen</strong> basiert.</p>
<h2><a class="anchor" aria-hidden="true" id="wichtige-begriffe"></a><a href="#wichtige-begriffe" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Wichtige Begriffe</h2>
<p>Im folgenden werden die Begriffe am Beispiel der <a href="millis#blinken-mit-millis">blinkenden LED mit der millis()-Funktion</a> erläutert:</p>
<ul>
<li><strong>Zustände</strong> speichern Information bzw. einen Status ab. In unserem Beispiel wird dafür die Variable <code>zustandLED</code> verwendet, welche angibt, ob die LED an- oder ausgeschaltet ist. Zustände alleine ändern das System jedoch nicht, dafür ist immer eine <em>Aktion</em> notwendig!</li>
<li>Durch eine <strong>Aktion</strong> wird der Zustand des endlichen Automaten geändert. Wann ein bestimmter Zustand geändert bzw. angenommen wird, hängt von dem System ab. Bei der blinkenden LED wird der Zustand des Automaten mit dem Befehl <code>digitalWrite(LED, zustandLED)</code> nach der Zeitabfrage geändert.</li>
<li><strong>Zustandsübergänge</strong> oder auch <strong>Zustandsänderungen</strong> werde in der Regel durch Programmverzweigungen wie <code>if-else</code> oder <code>switch-case</code> beschrieben. Sie geben an unter welchen Bedingungen ein Zustand in einen anderen wechseln soll. Beim Blink-Beispiel gib es genau zwei Zustandsänderungen: Anschalten und Ausschalten der LED.</li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="zustandsdiagramm"></a><a href="#zustandsdiagramm" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Zustandsdiagramm</h2>
<p>Mit einem Zustandsdiagramm lassen sich endliche Automaten graphisch darstellen. Das abgebildete Zustandsdiagramm beschreibt den endlichen Automaten für die <a href="millis#blinken-mit-millis">blinkende LED</a>.</p>
<p><img src="../img/Automat.png" alt="drawing" width=460pt height=auto/></p>
<p>In einem Zustandsdiagramm wird das Verhalten eines endlichen Automaten anschaulich dargestellt. Die <strong>Zustände</strong> des Automaten werden hierbei mit Kreisen oder abgerundeten Vierecken abgebildet. Jeder Zustand darf nur einmal dargestellt werden.</p>
<p>Erlaubte <strong>Zustandsübergänge</strong> werden mit Pfeilen dargestellt. <strong>Aktionen</strong> die zu Zustandsänderungen führen müssen nicht unbedingt dargestellt werden, können für das Verständnis aber sehr hilfreich sein. Das gleiche gilt für die Bedingungen, unter welchen der Automat seine Zustände ändert.</p>
<p>Im Allgemeinen gilt, so lange wie es dem Verständnis und der Übersichtlichkeit dient, sollten die Aktionen und die notwendigen Bedingungen vermerkt werden, ansonsten ist darauf zu verzichten.</p>
<h2><a class="anchor" aria-hidden="true" id="programmiertechniken"></a><a href="#programmiertechniken" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Programmiertechniken</h2>
<p>Im Abschnitt <a href="millis">Zeitkritische Aufgaben</a> wurde der oben abgebildete Automat mit Hilfe der Variablen <code>int zustandLED</code> und der <code>if-else</code> Verzweigung programmiert. Bei Automaten mit mehr als nur zwei Zuständen oder bei geschachtelten Automaten gibt es jedoch einen besseren Ansatz, der das Programm übersichtlicher und lesbarer macht.</p>
<p>Ein etwas komplexerer Automat, welcher im folgenden programmiert werden soll, lässt sich mit zwei LEDs erstellen. Ähnlich wie bei der blinken LED, wechselt der Automat nach einer vorgegeben Zeitspanne seinen Zustand. Im Zustandsdiagramm sind die vier möglichen Zustände mit den erlaubten Zustandsübergängen abgebildet.</p>
<p><img src="../img/Automat2LEDs.png" alt="drawing" width=430pt height=auto/></p>
<h3><a class="anchor" aria-hidden="true" id="enum-aufzählungstyp"></a><a href="#enum-aufzählungstyp" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>enum</code> Aufzählungstyp</h3>
<p>Das Schlüsselwort <code>enum</code> ermöglicht die Aufzählung von Konstanten. Mit <code>enum</code> wird ein Aufzählungstyp deklariert:</p>
<pre><code class="hljs css language-Arduino"><span class="hljs-keyword">enum</span> LedStates {AUS, LED1, LED12, LED2};  <span class="hljs-comment">// Typendeklaration (Aufzählungstyp)</span>
</code></pre>
<p>Mit dieser Zeile wird der Aufzählungstyp  <code>LedStates</code> mit den Konstanten <code>AUS</code>, <code>LED1</code>, <code>LED12</code>, <code>LED2</code> deklariert.</p>
<p>Nach dieser Deklaration ist es möglich die Variable <code>ledState</code> als <code>LedStates</code>-Typ zu deklarieren und ihr den Wert <code>AUS</code> zuzuweisen.</p>
<pre><code class="hljs css language-Arduino">LedStates ledState; <span class="hljs-comment">// Variablendeklaration</span>
ledState = AUS;     <span class="hljs-comment">// Variablenzuweisung</span>
</code></pre>
<p>Da der <code>LedStates</code> vorher als Aufzählungstyp deklariert wurde, kann der Variablen <code>ledState</code> nur eine der vorher deklarierten Werte zugewiesen werden. Hier wird der Variablen <code>ledState</code> der Wert <code>AUS</code> zugewiesen.</p>
<p>Wie bei einfachen Variablen, kann die Deklaration und die Zuweisung auch in einer Zeile durchgeführt werden.</p>
<pre><code class="hljs css language-Arduino">LedStates ledState  = AUS;; <span class="hljs-comment">// Variablendeklaration und Zuweisung</span>
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="switch-case-verzweigung"></a><a href="#switch-case-verzweigung" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>switch-case</code> Verzweigung</h3>
<p>Ähnlich wie bei der <code>if</code> Verzweigung, ermöglicht es die <a href="https://www.arduino.cc/reference/de/language/structure/control-structure/switchcase/"><code>switch-case</code> Verzweigung</a> den Programmablauf in Abhängigkeit von verschiedene Bedingungen zu kontrollieren. Besonders geeignet ist die  <code>switch-case</code> Verzweigung für den Fall, dass viele verschieden Bedingungen abgefragt werden sollen.</p>
<p>Als einfaches Beispiel wird die Variable <code>a</code> ausgewertet. Für den Fall, dass <code>a</code> die Werte <code>1</code>, <code>2</code> oder <code>3</code> annimmt, soll das Programm spezielle Anweisungen ausführen. Für alle anderen Werte von <code>a</code> wird der so genannte Default-Fall ausgeführt.</p>
<pre><code class="hljs css language-Arduino"><span class="hljs-keyword">int</span> a = <span class="hljs-number">2</span>;

<span class="hljs-keyword">switch</span> (a)  <span class="hljs-comment">// Nach dem Schlüsselwort folgt in Klammern der auszuwertende Ausdruck</span>
{
  <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:   <span class="hljs-comment">// Vergleicht den auszuwertende Ausdruck (a) mit dem Wert nach case (hier 1).</span>
    <span class="hljs-comment">// Mache etwas ..</span>
  <span class="hljs-keyword">break</span>; <span class="hljs-comment">// Beendet die Switch-Verzweigung. Die folgenden case-Abfragen werden nicht mehr durchgeführt</span>

  <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:
    <span class="hljs-comment">// Da a=2 ist, würde der hier stehen Code ausgeführt werden ...</span>
  <span class="hljs-keyword">break</span>;

  <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:
    <span class="hljs-comment">// Mache etwas anderes ..</span>
  <span class="hljs-keyword">break</span>;

  <span class="hljs-keyword">default</span>: 
    <span class="hljs-comment">// Wenn a keinem der aufgeführten Werte entspricht,</span>
    <span class="hljs-comment">// wird der Default-Fall ausgeführt.</span>
}
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="arduino-programmbeispiel"></a><a href="#arduino-programmbeispiel" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Arduino-Programmbeispiel</h3>
<p>Die <code>switch-case</code> Verzweigung eignet sich zusammen mit der <code>enum</code> Aufzählung besonders gut zur Programmierung eines Automaten. Am Beispiel des Automaten mit 2 LEDs soll das Grundprinzip erläutert werden.</p>
<pre><code class="hljs css language-Arduino">
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pinLed1 6  <span class="hljs-comment">// LED_1</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pinLed2 5  <span class="hljs-comment">// LED_2</span></span>


<span class="hljs-comment">// Zustände des Automaten als Aufzählungstyp deklarieren</span>
<span class="hljs-keyword">enum</span> LedStates {AUS, LED_1, LED_12, LED_2};
LedStates ledState = AUS;

<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> letzteZeit = <span class="hljs-number">0</span>;  <span class="hljs-comment">//  Zeitpunkt letzte LED-Änderung</span>
<span class="hljs-keyword">const</span>    <span class="hljs-keyword">long</span> intervall  = <span class="hljs-number">500</span>;    <span class="hljs-comment">// Blinkintervall in ms (Konstante)</span>


<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setup</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-built_in">pinMode</span>(pinLed1, <span class="hljs-literal">OUTPUT</span>);
  <span class="hljs-built_in">pinMode</span>(pinLed2, <span class="hljs-literal">OUTPUT</span>);
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">loop</span><span class="hljs-params">()</span> </span>{

  <span class="hljs-comment">// Bedingung für den Zustandsübergang. Der Automat soll seine Zustand nur ändern,</span>
  <span class="hljs-comment">// wenn die angegeben Intervall-Zeit überschritten ist.</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">millis</span>() - letzteZeit &gt;= intervall)
  {
    letzteZeit = <span class="hljs-built_in">millis</span>();  <span class="hljs-comment">// Zeitstempel für Zeitvergleich</span>

    <span class="hljs-comment">/* Jeder case der switch-Verzweigung entspricht dem *alten* Zustand des Automaten
        und gibt an, in welchen neuen Zustand gewechselt werden soll. In der
        case-Anweisung wird der neue Zustand des Automaten aktualisiert.
        Der neue Zustand wird sofort aktiviert, die entsprechenden LEDs
        werden also an oder ausgeschaltet.
    */</span>
    <span class="hljs-keyword">switch</span> (ledState)
    {
      <span class="hljs-keyword">case</span> AUS:                      <span class="hljs-comment">// aktueller Zustand: AUS</span>
        ledState = LED_1;            <span class="hljs-comment">// neuer Zustand des Automaten: LED_1</span>
        <span class="hljs-built_in">digitalWrite</span>(pinLed1, <span class="hljs-literal">HIGH</span>); <span class="hljs-comment">// LED_1 AN</span>
        <span class="hljs-built_in">digitalWrite</span>(pinLed2, <span class="hljs-literal">LOW</span>);  <span class="hljs-comment">// LED_2 AUS</span>
        <span class="hljs-keyword">break</span>;                       <span class="hljs-comment">// ohne die break-Anweisung würde sofort 'case LED_2' ausgeführt werden</span>

      <span class="hljs-keyword">case</span> LED_1:                    <span class="hljs-comment">// aktueller Zustand: LED 1 an</span>
        ledState = LED_12;
        <span class="hljs-built_in">digitalWrite</span>(pinLed1, <span class="hljs-literal">HIGH</span>);
        <span class="hljs-built_in">digitalWrite</span>(pinLed2, <span class="hljs-literal">HIGH</span>);
        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> LED_12:                   <span class="hljs-comment">// aktueller Zustand: LED 1&amp;2 an</span>
        ledState = LED_2;
        <span class="hljs-built_in">digitalWrite</span>(pinLed1, <span class="hljs-literal">LOW</span>);
        <span class="hljs-built_in">digitalWrite</span>(pinLed2, <span class="hljs-literal">HIGH</span>);
        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> LED_2:                    <span class="hljs-comment">// aktueller Zustand: LED 2 an</span>
        ledState = AUS;
        <span class="hljs-built_in">digitalWrite</span>(pinLed1, <span class="hljs-literal">LOW</span>);
        <span class="hljs-built_in">digitalWrite</span>(pinLed2, <span class="hljs-literal">LOW</span>);
        <span class="hljs-keyword">break</span>;

        <span class="hljs-comment">// Der Default-Fall wird nicht benötigt, da alle Wert abgefragt werde.</span>
    }
  }
}
</code></pre>
<blockquote>
<p>Automaten und Zustandsdiagramme sind besonders bei der Programmierung von <strong>Robotern</strong> sehr wichtig, da diese ein Vielzahl verschiedener Zustände einnehmen können.</p>
</blockquote>
<h2><a class="anchor" aria-hidden="true" id="aufgaben"></a><a href="#aufgaben" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Aufgaben</h2>
<div id="aufgabe">
<ol>
<li><p>Kopieren Sie des <a href="stateMachine#arduino-programmbeispiel">Beispielprogramm</a> und lassen sie es auf Ihrem Arduino mit der entsprechenden Schaltung laufen. Untersuchen Sie, was passiert, wenn einige der <code>break</code>-Anweisung auskommentiert (<code>//</code>) werden. Wie verhällt sich dann Ihr Programm?</p></li>
<li><p>Zeichnen Sie ein Zustandsdiagramm für den Automaten mit <strong>zwei LEDs,</strong> bei dem folgende Übergänge bzw. Zustände erlaubt sind. Nach dem letzten Zustand springt der Automat in der ersten Zustand zurück.</p>
<p>alle Leds <strong>aus</strong> <span>→</span> Led <strong>1 an</strong>, Led 2 aus <span>→</span> alle Leds <strong>aus</strong> <span>→</span>  Led <strong>1&amp;2 an</strong> <span>→</span>  alle LEDs <strong>aus</strong> <span>→</span> Led <strong>2 an</strong>, Led 1 aus <span>→</span> . . .</p></li>
<li><p>Schreiben Sie ein Programm für den obigen Automaten und testen Sie es an einer entsprechenden Schaltung.</p></li>
<li><p>Ändern Sie das Programm für den ursprünglichen <a href="stateMachine#arduino-programmbeispiel">Automaten mit 2 LEDs</a> so, dass für jeden der vier Zustände ein eigenes Zeitintervall (<code>dTime1</code>, <code>dTime2</code>,...) angegeben werden kann, in welchem er aktiv ist. Oder anders ausgedrückt, jeder der vier Zustände soll unterschiedlich lange aktiv sein.</p></li>
<li><p>Entwickeln Sie ein Programm und eine elektrische Schaltung zur Simulation  einer <strong>Ampelanlage für Fußgänger</strong> (eine Fußgängerampel <code>FA</code> und eine Ampel für PKWs <code>PA</code>). Ähnlich wie  bei <em>echten</em> Ampelanlagen für Fußgänger, darf die Fußgängerampel erst nach dem Betätigen eines Tasters (<em>Anforderung durch einen Fußgänger</em>) und einer gewissen Wartezeit auf Grün umschalten.  Beachten Sie bei der Bearbeitung der Aufgabe folgende Punkte:</p>
<ul>
<li>Erstellen Sie ein <strong>vollständiges Zustandsdiagramm</strong> für beide Ampeln. Recherchieren Sie die möglichen Zustände der Ampeln und benennens Sie diese sinnvoll (<code>FArot</code>, <code>FAgrün</code>, <code>PArot</code>, ...). Geben Sie im Zustandsdiagramm alle Zustände und Bedingungen für die Zustandsübergänge korrekt an.</li>
<li><strong>Entwickeln Sie eine Schaltung</strong> für die Ampelanlage. **Zeichnen Sie Ihre Schaltung auf **und bauen Sie sie anschließend auf dem Steckbrett auf. Vergessen Sie nicht den Taster für die Fußgängeranforderung.</li>
<li><strong>Schreiben Sie ein Programm</strong>, welches ihr Zustandsdiagramm umsetzt. Verwenden Sie die <code>switch-case</code>-Anweisung.</li>
</ul></li>
</ol>
</div>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/docs/millis"><span class="arrow-prev">← </span><span>Zeitkritische Aufgaben</span></a><a class="docs-next button" href="/docs/debounce"><span>Entprellen</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#wichtige-begriffe">Wichtige Begriffe</a></li><li><a href="#zustandsdiagramm">Zustandsdiagramm</a></li><li><a href="#programmiertechniken">Programmiertechniken</a><ul class="toc-headings"><li><a href="#enum-aufzählungstyp"><code>enum</code> Aufzählungstyp</a></li><li><a href="#switch-case-verzweigung"><code>switch-case</code> Verzweigung</a></li><li><a href="#arduino-programmbeispiel">Arduino-Programmbeispiel</a></li></ul></li><li><a href="#aufgaben">Aufgaben</a></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/" class="nav-home"><img src="/img/LogoSmallRed.svg" alt="Let&#x27;s rule the bots!  " width="66" height="58"/></a><div><a href="/blog">Blog</a><a href="https://www.youtube.com/watch?v=ARJ8cAGm6JE">HAL 9000</a></div><div></div></section><section class="copyright">Copyright © 2019 Stefan Warm</section></footer></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                
                apiKey: '8a8e0b313860e2fe23d0d40ec6dcd649',
                indexName: 'spacehal',
                inputSelector: '#search_input_react',
                algoliaOptions: {}
              });
            </script></body></html>