<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Steuern zeitkritischer Aufgaben · Let&#x27;s rule the bots!  </title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="Bisher wurde nur die `delay()` Methode zum Steuern von zeitkritischen Abläufen verwendet, welche den Programmablauf für die angegeben Zeit unterbricht. Hierbei handelt es sich um eine blockierende Funktion, da es während der Programmverzögerung nicht möglich vom Mikrocontroller andere Aufgaben ausführen zu lassen."/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Steuern zeitkritischer Aufgaben · Let&#x27;s rule the bots!  "/><meta property="og:type" content="website"/><meta property="og:url" content="https://spacehal.github.io/"/><meta property="og:description" content="Bisher wurde nur die `delay()` Methode zum Steuern von zeitkritischen Abläufen verwendet, welche den Programmablauf für die angegeben Zeit unterbricht. Hierbei handelt es sich um eine blockierende Funktion, da es während der Programmverzögerung nicht möglich vom Mikrocontroller andere Aufgaben ausführen zu lassen."/><meta property="og:image" content="https://spacehal.github.io/img/undraw_online.svg"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://spacehal.github.io/img/undraw_tweetstorm.svg"/><link rel="shortcut icon" href="/img/LogoSmallRed.svg"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/railscasts.min.css"/><link rel="alternate" type="application/atom+xml" href="https://spacehal.github.io/blog/atom.xml" title="Let&#x27;s rule the bots!   Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://spacehal.github.io/blog/feed.xml" title="Let&#x27;s rule the bots!   Blog RSS Feed"/><link rel="stylesheet" href="/css/code-block-buttons.css"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script><script type="text/javascript" src="/js/code-block-buttons.js"></script><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="/img/LogoSmallRed.svg" alt="Let&#x27;s rule the bots!  "/><h2 class="headerTitleWithLogo">Let&#x27;s rule the bots!  </h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/docs/helloworld" target="_self">Arduino</a></li><li class=""><a href="/docs/zumoInstallation" target="_self">Zumo</a></li><li class=""><a href="/docs/botEdgeFollower" target="_self">Robotik</a></li><li class=""><a href="/docs/moreInfo" target="_self">Links</a></li><li class=""><a href="/blog/" target="_self">Blog</a></li><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Grundlagen</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">Grundlagen<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/helloworld">Hallo Welt</a></li><li class="navListItem"><a class="navItem" href="/docs/input">Digitale Eingaben</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/docs/millis">Zeitkritische Aufgaben</a></li><li class="navListItem"><a class="navItem" href="/docs/seriell">Serielle Schnittstelle</a></li><li class="navListItem"><a class="navItem" href="/docs/debounce">Entprellen</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">Motorsteuerung<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/motorHBridge">Motor mit H-Brücke</a></li><li class="navListItem"><a class="navItem" href="/docs/motorPWM">Motordrehzahl</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 class="postHeaderTitle">Steuern zeitkritischer Aufgaben</h1></header><article><div><span><p>Bisher wurde nur die <code>delay()</code> Methode zum Steuern von zeitkritischen Abläufen verwendet, welche den Programmablauf für die angegeben Zeit unterbricht. Hierbei handelt es sich um eine blockierende Funktion, da es während der Programmverzögerung nicht möglich vom Mikrocontroller andere Aufgaben ausführen zu lassen.</p>
<h2><a class="anchor" aria-hidden="true" id="die-millis-methode"></a><a href="#die-millis-methode" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Die <code>millis()</code> Methode</h2>
<p>Eine besser Möglichkeit zur Steuerung von zeitlichen Abläufen ergibt sich mit der <code>millis()</code> Methode, welche die (vergangene) Zeit seit dem Programmstart angibt.</p>
<p>Durch den Aufruf der folgenden Zeilen ist es möglich, die seit dem Start des Arduinos vergangene Zeit in Millisekunden zu bestimmen.</p>
<pre><code class="hljs css language-Arduino"><span class="hljs-keyword">long</span> aktuelleZeit;         <span class="hljs-comment">// Variable vom Typ long (32 bit) für die Zeit</span>
aktuelleZeit = <span class="hljs-built_in">millis</span>();   <span class="hljs-comment">// seit dem Start des Arduino-Boards vergangene Zeit in ms</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="blinken-mit-millis"></a><a href="#blinken-mit-millis" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Blinken mit <code>millis()</code></h2>
<p>Im folgenden Programm wird nicht einfach nur bis zum Umschalten der LED mit der <code>delay()</code> Methode gewartet, sondern in einer Schleife <em>regelmäßig auf die Uhr geschaut</em>  und übeprüft, ob die LED umgeschaltet werden muss. Da nicht nur gewartet wird, sondern das vergangene Zeitintervall immer wieder überprüft wird, können zwischen jedem neuen Überprüfen der Zeit auch andere Aktionen ausgeführt werden.  Dies ist ein einfaches Konzept um <strong>Multitasking mit dem Arduino</strong> umzusetzen.</p>
<pre><code class="hljs css language-Arduino"><span class="hljs-comment">/* Lässt eine LED mit Hilfe der millis() Funktion blinken. Hierfür wird regelmäßig
   die Zeit gemessen, die seit dem letzten Umschalten der LED vergangen ist.
   Beim Überschreiten eine vorher angegebenen Zeitdifferenz wird die LED umgeschaltet. */</span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LED_ROT 9                    <span class="hljs-comment">// Pin der LED</span></span>

<span class="hljs-keyword">int</span> zustandLED = <span class="hljs-literal">LOW</span>;                <span class="hljs-comment">// zu setzender LED-Zustand (LOW = 0 = aus)</span>
<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> letzteLedZeit = <span class="hljs-number">0</span>;     <span class="hljs-comment">//  Zeitpunkt LED-Änderung</span>
<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> zeitDifferenz = <span class="hljs-number">1000</span>;  <span class="hljs-comment">// Blinkintervall in ms</span>

<span class="hljs-keyword">void</span> <span class="hljs-built_in">setup</span>() 
{
  <span class="hljs-built_in">pinMode</span>(LED_ROT, <span class="hljs-literal">OUTPUT</span>);          <span class="hljs-comment">// Pin als Output</span>
}

<span class="hljs-keyword">void</span> <span class="hljs-built_in">loop</span>() 
{           
  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> aktuelleZeit = <span class="hljs-built_in">millis</span>(); <span class="hljs-comment">// Zeit seit Programmstart in ms</span>

  <span class="hljs-comment">/* Wiederkehrend wird die Zeit bestimmt, die seit dem letzten Umschalten der LED
     vergangen ist. Ist die vergangene Zeit größer gleich `zeitDifferenz`, so wird de
     Wert von `zustandLED` angepasst und anschließend der Pin auf den entsprechenden
     Zustand gesetzt. */</span>
  <span class="hljs-built_in">if</span> (aktuelleZeit - letzteLedZeit &gt;= zeitDifferenz) 
  {
    <span class="hljs-built_in">if</span> (zustandLED == <span class="hljs-literal">LOW</span>) 
    {
      zustandLED = <span class="hljs-literal">HIGH</span>;
    } 
    <span class="hljs-built_in">else</span> 
    {
      zustandLED = <span class="hljs-literal">LOW</span>;
    }
    <span class="hljs-built_in">digitalWrite</span>(LED_ROT, zustandLED); <span class="hljs-comment">// Pin auf zustandLED setzen</span>
    letzteLedZeit = aktuelleZeit;      <span class="hljs-comment">// Zeit des Umschaltens speichern</span>
  }
}
</code></pre>
<h4><a class="anchor" aria-hidden="true" id="erlauterungen-zum-programm"></a><a href="#erlauterungen-zum-programm" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Erläuterungen zum Programm</h4>
<p>Die LED soll umgeschaltet werden, wenn seit dem letzten Umschalten eine festgelegte Zeit vergangen ist <code>aktuelleZeit - letzteLedZeit &gt;= intervall</code>. Diese Überprüfung findet in der <code>if-else</code>-Abfrage statt. Ist mehr Zeit als in <code>zeitDifferenz</code> angegeben vergangen, so wird als erstes der Zustand der LED überprüft:</p>
<pre><code class="hljs css language-Arduino"><span class="hljs-comment">/* Überprüfen des LED Zustands */</span>
<span class="hljs-built_in">if</span> (zustandLED == <span class="hljs-literal">LOW</span>) 
{
    zustandLED = <span class="hljs-literal">HIGH</span>;
} 
<span class="hljs-built_in">else</span> 
{
    zustandLED = <span class="hljs-literal">LOW</span>;
}
</code></pre>
<p>Hierfür wurde global die Zustandsvariable <code>zustandLED</code> definiert. Soll der Zustand der LED geändert werden (an oder aus), so wird der neue Zustand der LED in der Variable <code>zustandLED</code> vermerkt <strong>und anschließend</strong> über <code>digitalWrite(LED\_ROT,zustandLED)</code> der LED übergeben. Erst durch den Befehl <code>digitalWrite(LED_ROT, zustandLED);</code> wird die LED umgeschaltet!</p>
<h2><a class="anchor" aria-hidden="true" id="endliche-automaten-ea"></a><a href="#endliche-automaten-ea" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Endliche Automaten (EA)</h2>
<p>Programme oder etwas allgemeiner logische System, welche eine feste Anzahl verschiedener Zustände aufweisen und diese nach festgelegten Kriterien ändern sollen, können durch endliche Automaten (auch endliche Zustandsmaschine oder im Englischen <em>finit state machine</em> genannt) modelliert werden. Eine endlicher Automat soll ein Verhalten modellieren, welches auf einer endlichen Anzahl von <strong>Zuständen</strong>, <strong>Aktionen</strong> und <strong>Zustandsübergängen</strong> basiert.</p>
<ul>
<li><strong>Zustände</strong> speichen Information bzw. einen Status ab. In unserem Beispiel wird dafür die Variable <code>zustandLED</code> verwendet, welche angibt, ob die LED an oder aus sein soll. Zustände alleine ändern das System jedoch nicht, dafür ist immer ein <strong>Aktion</strong> notwendig!</li>
<li>Eine <strong>Aktion</strong> ist die Ausgabe der Zustände des endlichen Automaten. Wann die gespeicherten Zustände ausgegeben werden, hängt von dem System ab. Im obigen Beispiel wird der Zustand des Automaten mit dem Befehl <code>digitalWrite(LED_ROT, zustandLED)</code> immer nach der Abfrage für die Zustandsübergänge ausgegeben.</li>
<li><strong>Zustandsübergänge</strong> oder auch <strong>Zustandsänderungen</strong> werde in der Regel durch logische Bedingungen wie <code>if-else</code> beschrieben und geben an unter welchen Bedingungen ein Zustand in einen anderen wechseln soll. Beim Blink-Beispiel gib es genau zwei Zustandsänderungen: Anschalten und Ausschalten der LED.</li>
</ul>
<h3><a class="anchor" aria-hidden="true" id="zustandsdiagramm"></a><a href="#zustandsdiagramm" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Zustandsdiagramm</h3>
<p>Mit einem Zustandsdiagramm wie unten abgebildet, lassen sich endliche Automaten graphisch darstellen.
<img src="../img/Automat.png" alt="drawing" width=400pt height=auto/></p>
<p>Auch wenn bei dem Blink-Programm die Notwendigkeit eines endlichen Automatens nicht ganz offensichtlich ist, so gibt es gerade in der Robotik eine große Notwendigkeit, das Verhalten von Systemen mit einem endlichem Automaten darzustellen.</p>
<p>Ein einfacher Roboter, welcher einer Linie folgen und Hindernissen ausweichen soll, könnte folgende Zustände aufweisen:</p>
<p><strong>S1</strong>: <em>Pause</em>, <strong>S2</strong>: <em>Linie suchen</em>, <strong>S3</strong>: <em>Linie folgen</em>, <strong>S4</strong>: <em>Hindernis suchen</em>, <strong>S5</strong>: <em>Hindernis ausweichen</em></p>
<p>Da der Mikrocontroller aber letztlich immer nur eine Aktion zu selben Zeit ausführen kann, muss in einem Programm genau festgelegt werden, wann der Roboter welchen Zustand einnimmt, und durch welche Bedingungen er die Zustände wechseln kann. Dafür eignen sich endliche Automaten sehr gut.</p>
<h2><a class="anchor" aria-hidden="true" id="aufgaben"></a><a href="#aufgaben" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Aufgaben</h2>
<p>Verwenden Sie zum Lösen der Aufgaben nicht die <code>delay()</code> Funktion.</p>
<div id="aufgabe">
<ol>
<li>Schreiben Sie ein Programm, welches eine LED mit verschiedene An- und Auszeiten blinken lässt.</li>
<li>Schließen Sie eine zweite LED an den Arduino an und lassen sie diese unabhängig von der ersten LED mit einem anderen Rhythmus blinken.</li>
<li>Schreiben Sie ein Programm, welches eine LED nur dann blinken lässt, wenn ein Taster gedrückt ist.</li>
</ol>
</div></span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/docs/input"><span class="arrow-prev">← </span><span>Digitale Eingaben</span></a><a class="docs-next button" href="/docs/seriell"><span>Serielle Schnittstelle</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#die-millis-methode">Die <code>millis()</code> Methode</a></li><li><a href="#blinken-mit-millis">Blinken mit <code>millis()</code></a></li><li><a href="#endliche-automaten-ea">Endliche Automaten (EA)</a><ul class="toc-headings"><li><a href="#zustandsdiagramm">Zustandsdiagramm</a></li></ul></li><li><a href="#aufgaben">Aufgaben</a></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/" class="nav-home"><img src="/img/LogoSmallRed.svg" alt="Let&#x27;s rule the bots!  " width="66" height="58"/></a><div><a href="/blog">Blog</a><a href="https://www.youtube.com/watch?v=ARJ8cAGm6JE">HAL 9000</a></div><div><a href="http://www.osztiem.de/home/startseite/">OSZ TIEM</a></div></section><section class="copyright">Copyright © 2019 Stefan Warm</section></footer></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                
                apiKey: '8a8e0b313860e2fe23d0d40ec6dcd649',
                indexName: 'spacehal',
                inputSelector: '#search_input_react',
                algoliaOptions: {}
              });
            </script></body></html>