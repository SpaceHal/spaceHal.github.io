<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Entprellen eine Tasters · Let&#x27;s rule the bots!  </title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="Entprellen eines Taster mit einem Arduino (mit Pseudo-Code)."/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Entprellen eine Tasters · Let&#x27;s rule the bots!  "/><meta property="og:type" content="website"/><meta property="og:url" content="https://spacehal.github.io/"/><meta property="og:description" content="Entprellen eines Taster mit einem Arduino (mit Pseudo-Code)."/><meta property="og:image" content="https://spacehal.github.io/img/undraw_online.svg"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://spacehal.github.io/img/undraw_tweetstorm.svg"/><link rel="shortcut icon" href="/img/LogoSmallRed.svg"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css"/><link rel="alternate" type="application/atom+xml" href="https://spacehal.github.io/blog/atom.xml" title="Let&#x27;s rule the bots!   Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://spacehal.github.io/blog/feed.xml" title="Let&#x27;s rule the bots!   Blog RSS Feed"/><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Raleway:300,300i,400,400i,500,600"/><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:200,300,300i,400,400i,500,600"/><link rel="stylesheet" href="/css/code-block-buttons.css"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script><script type="text/javascript" src="/js/code-block-buttons.js"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS_HTML"></script><script type="text/javascript" src="/js/load-mathjax_v2.js"></script><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="/img/LogoSmallRed.svg" alt="Let&#x27;s rule the bots!  "/><h2 class="headerTitleWithLogo">Let&#x27;s rule the bots!  </h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/docs/helloworld" target="_self">Arduino</a></li><li class=""><a href="/docs/botBeginning" target="_self">Robotik</a></li><li class=""><a href="/docs/zumoInstallation" target="_self">Zumo</a></li><li class=""><a href="/docs/moreInfo" target="_self">Links</a></li><li class=""><a href="/blog/" target="_self">Blog</a></li><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Grundlagen</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">Grundlagen<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/helloworld">Blinkende LED</a></li><li class="navListItem"><a class="navItem" href="/docs/seriell">Serielle Schnittstelle</a></li><li class="navListItem"><a class="navItem" href="/docs/variable">Variablen</a></li><li class="navListItem"><a class="navItem" href="/docs/loop">Schleifen</a></li><li class="navListItem"><a class="navItem" href="/docs/input">Taster und if-Verzweigung</a></li><li class="navListItem"><a class="navItem" href="/docs/arryAndFunc">Arrays und Funktionen</a></li><li class="navListItem"><a class="navItem" href="/docs/millis">Zeitkritische Aufgaben</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/docs/debounce">Einen Taster entprellen</a></li><li class="navListItem"><a class="navItem" href="/docs/stateMachine">Endliche Automaten</a></li><li class="navListItem"><a class="navItem" href="/docs/pwm">PWM Signal</a></li><li class="navListItem"><a class="navItem" href="/docs/analogInput">Analoger Eingang</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">Motoren<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/motorWieEsBegann">Wie es begann</a></li><li class="navListItem"><a class="navItem" href="/docs/motorBasics">Grundlagen Gleichstrommotor</a></li><li class="navListItem"><a class="navItem" href="/docs/motorHBridge">H-Brücke</a></li><li class="navListItem"><a class="navItem" href="/docs/motorDRV8833">Motortreiber DRV8833</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">Sensorik<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/irSensor">IR Sensor</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 id="__docusaurus" class="postHeaderTitle">Entprellen eine Tasters</h1></header><article><div><span><p>Wird ein einfacher Taster als <a href="input#ein-taster-zum-umschalten">Umschalter</a>, zum Beispiel zum An- und Ausschalten einer LED verwendet, kann es passieren, dass beim einmaligen Betätigen scheinbar zufällig manchmal geschaltet und manchmal nicht geschaltet wird.</p>
<p>Die Ursache für dieses scheinbar willkürliche Verhalten wird als Prellen (engl. <em>bouncing</em>) bezeichnet. Beim Drücken des Tasters ändert sich der Zustand am Eingangspin nicht nur einmal, sondern gelegentlich auch öfter. Ähnlich wie ein Lineal, welches auf einen Tisch geschlagen wird, springen die Kontakte eines Tasters beim Betätigen für einen kurzen Moment hin und her. Dies führt zu ungewollten, sich schnell ändernden Spannungszuständen am Eingangspin. Werden diese schnellen Zustandsänderungen verarbeitet, so scheint es, dass beim Betätigen des Tasters nichts passiert, obwohl in Wahrheit vielleicht angeschaltet und gleich danach wieder ausgeschaltet wurde.</p>
<p>Mit einem geeigneten Code können Taster entprellt werden, damit sie beim Betätigen auch wirklich nur einmal schalten.</p>
<h2><a class="anchor" aria-hidden="true" id="prellen-eines-tasters"></a><a href="#prellen-eines-tasters" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Prellen eines Tasters</h2>
<p><img src="../img/debounce.png" alt="drawing" width=340px height=auto/></p>
<p>In der oben stehenden Abbildung ist schematisch der Verlauf der Spannung bei einem LOW-aktiven Taster (Signalpegel LOW beim Drücken) dargestellt. Wird der Taster gedrückt, so fällt die Spannung am Eingangspin zuerst auf 0 V ab, springt jedoch gleich darauf wieder auf einen höheren Spannungswert. Würde jeder Zustandswechsel von <code>HIGH</code> auf <code>LOW</code> zum Umschalten der LED führen, so wäre bei einem prellenden Schalter nicht vorhersehbar, ob die LED zum Schluss an- oder ausgeschaltet ist.</p>
<h2><a class="anchor" aria-hidden="true" id="entprellen-debouncing"></a><a href="#entprellen-debouncing" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Entprellen (debouncing)</h2>
<p>Ein Taster ist entprellt, wenn die schnellen ungewollten Zustandsänderungen während des Drückens eines Tasters ignoriert wurden. Wird also am Tasterpin eine <strong>erste Zustandsänderung</strong> detektiert, müssen für eine vorgegebene Zeit (Prellzeit) alle folgenden <strong>unerwünschten Zustandsänderungen ignoriert</strong> werden. Da die meisten Taster nur in einem Zeitbereich \(\Delta t\) von ca. 30 ms prellen, sollte ein Prellzeit von 30 ms ausreichen.</p>
<p>Anschließend muss der <strong>Zustand des Tasters erneut eingelesen</strong> werden. Entspricht der Zustand dem nach der ersten Zustandänderung (<em>im Beispiel also LOW</em>), dann wurde der Taster erfolgreich entprellt.</p>
<blockquote>
<p>Was würde passieren, wenn die Prellzeit, also jene Zeit, in welcher aller unerwünschten Zustandsänderungen ignoriert werden, eine Sekunde beträgt?</p>
</blockquote>
<h3><a class="anchor" aria-hidden="true" id="einfaches-blockierendes-entprellen"></a><a href="#einfaches-blockierendes-entprellen" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Einfaches (blockierendes) Entprellen</h3>
<p>Die einfachste, wenn auch nicht beste Lösung, um einen Taster zu entprellen, kann durch eine einfache blockierende Programmverzögerung mit der <code>delay()</code>-Funktion realisiert werden.</p>
<p>Im folgenden Beispiel wird die <strong>fallende Flanke</strong> des Tasterpins, als der Übergang von ungedrückt <code>HIGH</code> zu gedrückt <code>LOW</code> entprellt und zum Umschalten einer LED verwendet.</p>
<pre><code class="hljs css language-Arduino"><span class="hljs-comment">/* Ein sehr einfaches Beispiel zum Entprellen eines Tasters und Umschalten einer LED
   Dieses Beispiel blockiert den MC während des Entprellens. Eine bessere Lösung lässt
   sich mit der millis()-Funktion realisieren */</span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BUTTON 12                        <span class="hljs-comment">// an Schaltung anpassen</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LED 3                            <span class="hljs-comment">// an Schaltung anpassen</span></span>

<span class="hljs-keyword">int</span> stateButton      = <span class="hljs-literal">HIGH</span>;             <span class="hljs-comment">// aktueller Status des Taster-PINs</span>
<span class="hljs-keyword">int</span> stateButtonLast  = <span class="hljs-literal">HIGH</span>;             <span class="hljs-comment">// Status des Taster-PINs vor der letzten Überprüfung</span>
<span class="hljs-keyword">int</span> stateLED         = <span class="hljs-literal">LOW</span>;              <span class="hljs-comment">// Status der LED (an oder aus)</span>

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">umschaltenLED</span><span class="hljs-params">(<span class="hljs-keyword">int</span> pPin)</span></span>{
  stateLED = !stateLED;                  <span class="hljs-comment">// LED-Status umschalten</span>
  <span class="hljs-built_in">digitalWrite</span>(pPin, stateLED);          <span class="hljs-comment">// LED-Status aktualisieren</span>
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setup</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-built_in">pinMode</span>(BUTTON, <span class="hljs-literal">INPUT_PULLUP</span>);         <span class="hljs-comment">// Tasterpin mit Pull-Up-Widerstand konfigurieren</span>
  <span class="hljs-built_in">pinMode</span>(LED, <span class="hljs-literal">OUTPUT</span>);
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">loop</span><span class="hljs-params">()</span> </span>{
  stateButton = <span class="hljs-built_in">digitalRead</span>(BUTTON);     <span class="hljs-comment">// aktuellen Zustand des Tasters bestimmen</span>

  <span class="hljs-comment">// Ist Taster gedrückt ( stateButton == 0 ) UND war er vorher nicht gedrückt (stateButtonLast == 1)</span>
  <span class="hljs-keyword">if</span> ((stateButton == <span class="hljs-number">0</span>) &amp;&amp; (stateButtonLast == <span class="hljs-number">1</span>))
  {
    <span class="hljs-built_in">delay</span>(<span class="hljs-number">30</span>);                           <span class="hljs-comment">// 30 ms warten, um falsche Zustandsänderungen zu ignorieren</span>
    stateButton = <span class="hljs-built_in">digitalRead</span>(BUTTON);   <span class="hljs-comment">// Zustand des Taster überprüfen</span>
    <span class="hljs-keyword">if</span> (stateButton == <span class="hljs-number">0</span>) {              <span class="hljs-comment">// Ist der Taster immer noch gedrückt?</span>
      umschaltenLED(LED);                
    }
  }
  
  stateButtonLast = stateButton;         <span class="hljs-comment">// alten Wert des Tasters speichern</span>
}
</code></pre>
<blockquote>
<p><strong>Hinweis:</strong> Das Zeichen <code>!</code> ist das Negationszeichen und bedeutet <em>nicht</em>. Der Ausdruck <code>stateLED = !stateLED;</code> negiert als den Wert von <code>stateLED</code> (aus <code>0</code> wird <code>1</code> und aus <code>1</code> wird <code>0</code>).</p>
</blockquote>
<h3><a class="anchor" aria-hidden="true" id="pseudocode-nicht-blockierend-mit-millis"></a><a href="#pseudocode-nicht-blockierend-mit-millis" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Pseudocode (nicht blockierend mit <code>millis()</code>)</h3>
<p>Der Nachteil des obigen Codes zum Entprellen ist, dass der Programmablauf durch die <code>delay()</code> Funktion blockiert wird. Ein nichtblockierendes Entprellen lässt sich mit der <code>millis()</code> Funktion realisieren.</p>
<p>Der folgende <strong>unvollständige</strong> Programmcode zum Entprellen eines Tasters mit der <code>millis()</code>-Funktion zeigt beispielhaft, wie das Drücken eines Tasters (nicht das Loslassen) entprellt werden kann.</p>
<pre><code class="hljs css language-Arduino"><span class="hljs-comment">/* Unvollständiger Code zum Entprellen eines Tasters und umschalten einer LED*/</span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BUTTON 0                    <span class="hljs-comment">// an Schaltung anpassen</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LED 13                      <span class="hljs-comment">// an Schaltung anpassen</span></span>

<span class="hljs-keyword">bool</span> entprellen      = <span class="hljs-literal">false</span>;
<span class="hljs-keyword">int</span> stateButton      = <span class="hljs-literal">HIGH</span>;        <span class="hljs-comment">// aktueller  Status des Tasters</span>
<span class="hljs-keyword">int</span> stateButtonLast  = <span class="hljs-literal">HIGH</span>;        <span class="hljs-comment">// letzter  Status des Tasters</span>
<span class="hljs-keyword">int</span> stateLED         = <span class="hljs-literal">LOW</span>;         <span class="hljs-comment">// Status der LED (an oder aus)</span>

<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> entprellZeit = <span class="hljs-number">30</span>;    <span class="hljs-comment">// in ms</span>
<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> zeitTaster = <span class="hljs-number">0</span>;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setup</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-built_in">Serial</span>.<span class="hljs-built_in">begin</span>(<span class="hljs-number">115200</span>);
  <span class="hljs-built_in">pinMode</span>(BUTTON, <span class="hljs-literal">INPUT_PULLUP</span>);    <span class="hljs-comment">// interner Pull-Up-Widerstand</span>
  <span class="hljs-built_in">pinMode</span>(LED, <span class="hljs-literal">OUTPUT</span>);
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">loop</span><span class="hljs-params">()</span> </span>{
  stateButton = <span class="hljs-built_in">digitalRead</span>(BUTTON); <span class="hljs-comment">// Taster-Pin einlesen</span>

  <span class="hljs-comment">// Wurde der Taster gedrückt?</span>
  <span class="hljs-keyword">if</span> ((stateButton == <span class="hljs-number">0</span>) &amp;&amp; (stateButtonLast == <span class="hljs-number">1</span>)) {

    <span class="hljs-comment">// Zeitstempel zum Entprellen zurücksetzen und merken, dass</span>
    <span class="hljs-comment">// beim nächsten Durchlauf enprellt werden muss:</span>
    zeitTaster = <span class="hljs-built_in">millis</span>();
    entprellen = <span class="hljs-literal">true</span>;
  }

  <span class="hljs-comment">// Die Zustandsänderung wurde bereits erkannt, jetzt wird entprellt:</span>
  <span class="hljs-keyword">if</span> (entprellen)
  {
    <span class="hljs-comment">/*                PSEUDOCODE zum Entprellen
      --------------------------------------------------------
      WENN (Zeit seit letzter Änderung am Pin &gt; entprellZeit)
      {
        WENN (Taster immer noch gedrückt)
        {
          - stateLED umschalten
          - entprellen beenden
        }
      }
      --------------------------------------------------------
    */</span>
  }
  stateButtonLast = stateButton;      <span class="hljs-comment">// alten Tasterzustand speichern</span>
  <span class="hljs-built_in">digitalWrite</span>(LED, stateLED);        <span class="hljs-comment">// LED-Status aktualisieren</span>
}
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="aufgaben"></a><a href="#aufgaben" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Aufgaben</h3>
<div id="aufgabe">
<ol>
<li>Erläutern Sie, warum nach der Prellzeit der Zustand des Tasters überprüft werden muss.</li>
<li>Vervollständigen Sie den nicht blockierenden Code zum Entprellen eines Tasters. Beim Betätigen des Tasters soll eine angeschlossene LED an- bzw. ausgeschaltet werden (toggeln).</li>
<li>Bauen Sie eine Schaltung mit 4 gleichfarbigen LEDs und einem Taster auf. Zu Beginn leuchtet nur die erste LED. Beim ersten Betätigen des Taster soll die zweite LED aufleuchten und alle anderen LEDs aus sein. Wird der Taster ein weiteres Mal betätigt, so soll die 3. LED aufleuchten, danach die 4. LED und so weiter. Verwenden Sie einen geeigneten <strong>Automaten</strong>.</li>
<li>Bauen Sie eine Schaltung mit zwei LEDs und zwei Tastern auf. Schreiben Sie ein Programm, das jede LED mit einem einzelnen Taster an und ausschalten lässt (Taster 1 schaltet nur LED 1 und Taster 2 schaltet nur LED 2). Achten Sie darauf die Taster zu entprellen.</li>
</ol>
</div>
<h2><a class="anchor" aria-hidden="true" id="bounce2-bibliothek-zum-entprellen"></a><a href="#bounce2-bibliothek-zum-entprellen" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Bounce2-Bibliothek zum Entprellen</h2>
<p>Mit der Arduino-Bibliothek <strong><a href="https://github.com/thomasfredericks/Bounce2">bounce2</a></strong> kann das Entprellen stark vereinfacht werden. Die Dokumentation findet sich <a href="http://thomasfredericks.github.io/Bounce2/files/index.html">hier</a>.</p>
<pre><code class="hljs"><span class="hljs-comment">// This example toggles the debug LED (pin 13) on or off</span>
<span class="hljs-comment">// when a button on pin 2 is pressed.</span>

<span class="hljs-comment">// Include the Bounce2 library found here :</span>
<span class="hljs-comment">// https://github.com/thomasfredericks/Bounce2</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;Bounce2.h&gt;</span></span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BUTTON_PIN 2</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LED_PIN 13</span>
<span class="hljs-keyword">int</span> ledState = <span class="hljs-literal">LOW</span>;

Bounce debouncer = Bounce(); <span class="hljs-comment">// Instantiate a Bounce object</span>

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setup</span><span class="hljs-params">()</span> </span>{
  debouncer.<span class="hljs-built_in">attach</span>(BUTTON_PIN,<span class="hljs-literal">INPUT_PULLUP</span>); <span class="hljs-comment">// Attach the debouncer to a pin with INPUT_PULLUP mode</span>
  debouncer.interval(<span class="hljs-number">25</span>); <span class="hljs-comment">// Use a debounce interval of 25 milliseconds</span>
  
  <span class="hljs-built_in">pinMode</span>(LED_PIN,<span class="hljs-literal">OUTPUT</span>); <span class="hljs-comment">// Setup the LED</span>
  <span class="hljs-built_in">digitalWrite</span>(LED_PIN,ledState);
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">loop</span><span class="hljs-params">()</span> </span>{
   debouncer.update();               <span class="hljs-comment">// Update the Bounce instance</span>
   
   <span class="hljs-keyword">if</span> ( debouncer.fell() ) {         <span class="hljs-comment">// Call code if button transitions from HIGH to LOW</span>
     ledState = !ledState;           <span class="hljs-comment">// Toggle LED state</span>
     <span class="hljs-built_in">digitalWrite</span>(LED_PIN,ledState); <span class="hljs-comment">// Apply new LED state</span>
   }
}

</code></pre>
<h2><a class="anchor" aria-hidden="true" id="links"></a><a href="#links" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Links</h2>
<ul>
<li><a href="http://www.skillbank.co.uk/arduino/switchbounce.htm">Using digital inputs: Switch bounce and solutions to it</a></li>
<li><a href="https://github.com/thomasfredericks/Bounce2">Arduino Library Bounce2</a></li>
<li>Die <a href="https://github.com/LennartHennigs/Button2">Button2-Bibliothek</a> ist deutlich umfangreicher als die Bounce2 Bibliothek und ermöglicht das Arbeit mit Eventhandlern für verschiedene Taster-Events wie <em>Click</em>, <em>LongClick</em>, <em>DoubleClick</em>, <em>TripleClick</em>.</li>
</ul>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/docs/millis"><span class="arrow-prev">← </span><span>Zeitkritische Aufgaben</span></a><a class="docs-next button" href="/docs/stateMachine"><span>Endliche Automaten</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#prellen-eines-tasters">Prellen eines Tasters</a></li><li><a href="#entprellen-debouncing">Entprellen (debouncing)</a><ul class="toc-headings"><li><a href="#einfaches-blockierendes-entprellen">Einfaches (blockierendes) Entprellen</a></li><li><a href="#pseudocode-nicht-blockierend-mit-millis">Pseudocode (nicht blockierend mit <code>millis()</code>)</a></li><li><a href="#aufgaben">Aufgaben</a></li></ul></li><li><a href="#bounce2-bibliothek-zum-entprellen">Bounce2-Bibliothek zum Entprellen</a></li><li><a href="#links">Links</a></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/" class="nav-home"><img src="/img/LogoSmallRed.svg" alt="Let&#x27;s rule the bots!  " width="66" height="58"/></a><div><a href="/blog">Blog</a><a href="https://www.youtube.com/watch?v=ARJ8cAGm6JE">HAL 9000</a></div><div><a href="http://www.osztiem.de/home/startseite/">OSZ TIEM</a></div></section><section class="copyright">Copyright © 2021 Stefan Warm</section></footer></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                
                apiKey: '8a8e0b313860e2fe23d0d40ec6dcd649',
                indexName: 'spacehal',
                inputSelector: '#search_input_react',
                algoliaOptions: {}
              });
            </script></body></html>