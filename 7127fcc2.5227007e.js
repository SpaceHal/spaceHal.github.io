(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{131:function(e,n,t){"use strict";t.d(n,"a",(function(){return o})),t.d(n,"b",(function(){return p}));var i=t(0),r=t.n(i);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function l(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);n&&(i=i.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,i)}return t}function d(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?l(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):l(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,i,r=function(e,n){if(null==e)return{};var t,i,r={},a=Object.keys(e);for(i=0;i<a.length;i++)t=a[i],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(i=0;i<a.length;i++)t=a[i],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var c=r.a.createContext({}),u=function(e){var n=r.a.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):d(d({},n),e)),t},o=function(e){var n=u(e.components);return r.a.createElement(c.Provider,{value:n},e.children)},b={inlineCode:"code",wrapper:function(e){var n=e.children;return r.a.createElement(r.a.Fragment,{},n)}},m=r.a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,a=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),o=u(t),m=i,p=o["".concat(l,".").concat(m)]||o[m]||b[m]||a;return t?r.a.createElement(p,d(d({ref:n},c),{},{components:t})):r.a.createElement(p,d({ref:n},c))}));function p(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var a=t.length,l=new Array(a);l[0]=m;var d={};for(var s in n)hasOwnProperty.call(n,s)&&(d[s]=n[s]);d.originalType=e,d.mdxType="string"==typeof e?e:i,l[1]=d;for(var c=2;c<a;c++)l[c]=t[c];return r.a.createElement.apply(null,l)}return r.a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},95:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return l})),t.d(n,"metadata",(function(){return d})),t.d(n,"rightToc",(function(){return s})),t.d(n,"default",(function(){return u}));var i=t(3),r=t(7),a=(t(0),t(131)),l={title:"Steuern zeitkritischer Aufgaben",sidebar_label:"8. Zeitkritische Aufgaben"},d={unversionedId:"arduino/millis",id:"arduino/millis",isDocsHomePage:!1,title:"Steuern zeitkritischer Aufgaben",description:"Bisher wurde nur die delay() Methode zum Steuern von zeitkritischen Abl\xe4ufen verwendet, welche den Programmablauf f\xfcr die angegeben Zeit unterbricht. Hierbei handelt es sich um eine blockierende Funktion, da der Mikrocontroller w\xe4hrend der Programmverz\xf6gerung keine anderen Aufgaben ausf\xfchren kann.",source:"@site/docs/arduino/millis.md",slug:"/arduino/millis",permalink:"/docs/arduino/millis",editUrl:"https://spacehal.github.io/docs/arduino/millis.md",version:"current",sidebar_label:"8. Zeitkritische Aufgaben",sidebar:"someSidebar",previous:{title:"Arrays (Listen)",permalink:"/docs/arduino/array"},next:{title:"Entprellen eine Tasters",permalink:"/docs/arduino/debounce"}},s=[{value:"<code>millis()</code>",id:"millis",children:[]},{value:"Blinken mit <code>millis()</code>",id:"blinken-mit-millis",children:[{value:"Erl\xe4uterungen zum Programm",id:"erl\xe4uterungen-zum-programm",children:[]}]},{value:"Aufgaben",id:"aufgaben",children:[]}],c={rightToc:s};function u(e){var n=e.components,t=Object(r.a)(e,["components"]);return Object(a.b)("wrapper",Object(i.a)({},c,t,{components:n,mdxType:"MDXLayout"}),Object(a.b)("p",null,"Bisher wurde nur die ",Object(a.b)("inlineCode",{parentName:"p"},"delay()")," Methode zum Steuern von zeitkritischen Abl\xe4ufen verwendet, welche den Programmablauf f\xfcr die angegeben Zeit unterbricht. Hierbei handelt es sich um eine ",Object(a.b)("strong",{parentName:"p"},"blockierende Funktion"),", da der Mikrocontroller w\xe4hrend der Programmverz\xf6gerung keine anderen Aufgaben ausf\xfchren kann."),Object(a.b)("h2",{id:"millis"},Object(a.b)("inlineCode",{parentName:"h2"},"millis()")),Object(a.b)("p",null,"Eine bessere M\xf6glichkeit zur Steuerung von zeitlichen Abl\xe4ufen ergibt sich mit der ",Object(a.b)("inlineCode",{parentName:"p"},"millis()")," Methode, welche die (vergangene) Zeit seit dem Programmstart angibt."),Object(a.b)("p",null,"Durch den Aufruf der folgenden Zeilen ist es m\xf6glich, die seit dem Start des Arduinos vergangene Zeit in Millisekunden zu bestimmen. "),Object(a.b)("pre",null,Object(a.b)("code",Object(i.a)({parentName:"pre"},{className:"language-arduino"}),"long aktuelleZeit;         // Variable vom Typ long (32 bit) f\xfcr die Zeit\naktuelleZeit = millis();   // seit dem Start des Arduino-Boards vergangene Zeit in ms\n")),Object(a.b)("p",null,"Da die R\xfcckgabewerte der ",Object(a.b)("inlineCode",{parentName:"p"},"millis()"),"-Funktion relativ schnell sehr gro\xdf werden k\xf6nnen, sollten diese  immer einer Variablen vom Typ  ",Object(a.b)("inlineCode",{parentName:"p"},"long")," oder besser vom Typ ",Object(a.b)("inlineCode",{parentName:"p"},"unsinged long")," \xfcbseregeben werden."),Object(a.b)("h2",{id:"blinken-mit-millis"},"Blinken mit ",Object(a.b)("inlineCode",{parentName:"h2"},"millis()")),Object(a.b)("p",null," Im folgenden Programm wird nicht einfach nur bis zum Umschalten der LED mit der ",Object(a.b)("inlineCode",{parentName:"p"},"delay()")," Methode gewartet, sondern in einer Schleife ",Object(a.b)("em",{parentName:"p"},"regelm\xe4\xdfig auf die Uhr geschaut"),"  und \xfcberpr\xfcft, ob die LED umgeschaltet werden muss. Da nicht nur gewartet wird, sondern das vergangene Zeitintervall immer wieder \xfcberpr\xfcft wird, k\xf6nnen zwischen jedem neuen \xdcberpr\xfcfen der Zeit auch andere Aktionen ausgef\xfchrt werden. Dies ist ein einfaches Konzept, um ",Object(a.b)("strong",{parentName:"p"},"Multitasking mit dem Arduino")," umzusetzen."),Object(a.b)("pre",null,Object(a.b)("code",Object(i.a)({parentName:"pre"},{className:"language-arduino"}),"// L\xe4sst eine LED mit Hilfe der millis() Funktion blinken. \n\n#define LED 2                        // Pin der LED\n\nint zustandLED = LOW;                // zu setzender LED-Zustand (LOW = 0 = aus)\nunsigned long letzteLedZeit = 0;     // Zeitpunkt LED-\xc4nderung\nunsigned long zeitDifferenz = 1000;  // Blinkintervall in ms\n\nvoid setup() \n{\n  pinMode(LED, OUTPUT);              // Pin als Output\n}\n\nvoid loop() \n{\n  //highlight-next-line         \n  unsigned long aktuelleZeit = millis(); // Zeit seit Programmstart in Millisekunden\n\n  // Es wird die Zeit bestimmt, die seit dem letzten Umschalten der LED vergangen ist.\n  // Ist die vergangene Zeit gr\xf6\xdfergleich `zeitDifferenz`, so wird der Wert von `zustandLED`\n  // angepasst und anschlie\xdfend der Pin auf den entsprechenden Zustand gesetzt.\n  //highlight-start\n  if (aktuelleZeit - letzteLedZeit >= zeitDifferenz) \n  {\n    if (zustandLED == LOW){ // \xdcberpr\xfcfen des LED Zustands\n      zustandLED = HIGH;\n    } \n    else{\n      zustandLED = LOW;\n    }\n    digitalWrite(LED, zustandLED);    // Pin auf `zustandLED` setzen\n    letzteLedZeit = aktuelleZeit;     // Zeit des Umschaltens speichern\n  }\n  //highlight-end\n}\n")),Object(a.b)("h3",{id:"erl\xe4uterungen-zum-programm"},"Erl\xe4uterungen zum Programm"),Object(a.b)("p",null,"Die LED soll umgeschaltet werden, wenn seit dem letzten Umschalten eine festgelegte Zeit vergangen ist. Diese \xdcberpr\xfcfung findet in der ",Object(a.b)("inlineCode",{parentName:"p"},"if-else"),"-Abfrage statt:"),Object(a.b)("pre",null,Object(a.b)("code",Object(i.a)({parentName:"pre"},{className:"language-arduino"}),"if (aktuelleZeit - letzteLedZeit >= zeitDifferenz) \n")),Object(a.b)("p",null,"Ist mehr Zeit als in ",Object(a.b)("inlineCode",{parentName:"p"},"zeitDifferenz")," angegeben vergangen, so wird als erstes der Zustand der LED \xfcberpr\xfcft:"),Object(a.b)("pre",null,Object(a.b)("code",Object(i.a)({parentName:"pre"},{className:"language-arduino"}),"if (zustandLED == LOW){ // \xdcberpr\xfcfen des LED Zustands\n  zustandLED = HIGH;\n} \nelse{\n  zustandLED = LOW;\n}\n")),Object(a.b)("p",null," Hierf\xfcr wurde global die Zustandsvariable ",Object(a.b)("inlineCode",{parentName:"p"},"zustandLED")," definiert. Soll der Zustand der LED ge\xe4ndert werden (an oder aus), so wird der neue Zustand der LED in der Variable ",Object(a.b)("inlineCode",{parentName:"p"},"zustandLED")," vermerkt ",Object(a.b)("strong",{parentName:"p"},"und anschlie\xdfend")," mit"),Object(a.b)("pre",null,Object(a.b)("code",Object(i.a)({parentName:"pre"},{className:"language-arduino"}),"digitalWrite(LED, zustandLED);    // Pin auf `zustandLED` setzen\n")),Object(a.b)("p",null,"der LED \xfcbergeben. Erst durch den Befehl ",Object(a.b)("inlineCode",{parentName:"p"},"digitalWrite()")," wird die LED umgeschaltet.\nAnschlie\xdfend muss der Zeitpunkt des Umschaltens gespeichert werden, damit sp\xe4ter wieder die Zeit zum erneuten Umschalten bestimmt werden kann:"),Object(a.b)("pre",null,Object(a.b)("code",Object(i.a)({parentName:"pre"},{className:"language-arduino"}),"letzteLedZeit = aktuelleZeit;     // Zeit des Umschaltens speichern\n")),Object(a.b)("h2",{id:"aufgaben"},"Aufgaben"),Object(a.b)("p",null,"Verwenden Sie zum L\xf6sen der Aufgaben die ",Object(a.b)("inlineCode",{parentName:"p"},"delay()")," Funktion."),Object(a.b)("div",{className:"admonition admonition-note alert alert--secondary"},Object(a.b)("div",Object(i.a)({parentName:"div"},{className:"admonition-heading"}),Object(a.b)("h5",{parentName:"div"},Object(a.b)("span",Object(i.a)({parentName:"h5"},{className:"admonition-icon"}),Object(a.b)("svg",Object(i.a)({parentName:"span"},{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"}),Object(a.b)("path",Object(i.a)({parentName:"svg"},{fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"})))),Object(a.b)("strong",{parentName:"h5"},"\xdcben"))),Object(a.b)("div",Object(i.a)({parentName:"div"},{className:"admonition-content"}),Object(a.b)("ol",{parentName:"div"},Object(a.b)("li",{parentName:"ol"},Object(a.b)("p",{parentName:"li"},"Schreiben Sie ein Programm, welches eine LED mit verschiedene An- und Auszeiten blinken la\u0308sst.")),Object(a.b)("li",{parentName:"ol"},Object(a.b)("p",{parentName:"li"},"Schlie\xdfen Sie eine zweite LED an den Arduino an und lassen sie diese unabh\xe4ngig von der ersten LED mit einem anderen Rhythmus blinken.")),Object(a.b)("li",{parentName:"ol"},Object(a.b)("p",{parentName:"li"},"Schreiben Sie ein Programm, welches eine LED nur dann blinken la\u0308sst, wenn ein Taster gedr\xfcckt ist.")),Object(a.b)("li",{parentName:"ol"},Object(a.b)("p",{parentName:"li"},"Bauen Sie eine Schaltung mit maximal 6 LEDs auf. Schreiben Sie ein Programm, welches die einzelnen LEDs nacheinander an und wieder ausschaltet, so dass Sie ein ",Object(a.b)("strong",{parentName:"p"},"Lauflicht")," erhalten. Das Lauflicht soll kontinuierlich hin- und herwandern. Nutzen Sie einen Array f\xfcr die verschiedenen LED-Pins und verwenden Sie ",Object(a.b)("strong",{parentName:"p"},"nicht")," die ",Object(a.b)("inlineCode",{parentName:"p"},"delay()"),"-Funktion."),Object(a.b)("p",{parentName:"li"},"Nutzen Sie die folgende Vorlage:"),Object(a.b)("pre",{parentName:"li"},Object(a.b)("code",Object(i.a)({parentName:"pre"},{className:"language-arduino"}),"#define NUMLED 6\nconst int pinsLED[]       = {3, 5, 6, 9, 10, 11};\nint ledStates[]           = {0, 0, 0, 0, 0, 0};  // gibt an, ob eine LED an oder ausgeschaltet ist\nunsigned long lastTime    = 0;\nunsigned long delayMillis = 100;\nint actualLED             = 0; // Index der aktuellen LED, also jener LED, die angeschaltet ist.\n\nvoid setup() {\n  Serial.begin(9600);\n  for (int i = 0; i < NUMLED; i++) {\n    pinMode(pinsLED[i], OUTPUT);\n  }\n}\n\n// Schaltet die LEDs entsprechend dem Array 'ledStates' an oder aus\nvoid setLeds(int pLedStates[]) {\n  for (int i =  0; i < NUMLED; i++) {\n    digitalWrite(pinsLED[i], pLedStates[i]);\n  }\n}\n\nvoid loop() {\n  if ( (millis() - lastTime) > delayMillis) {\n      /*\n        \xc4ndern sie in einer Schleifen die Werte des Arrays ledStates so,\n        dass sich ein Lauflicht wergibt.\n\n        Nutzen Sie die Funktion 'setLeds()' zum An-/Ausschalten der LEDs.\n      */\n\n    setLeds(ledStates);  // Funktion zum Schalten der LEDs\n    lastTime = millis(); // Zeitstempel \n  }\n}\n")))))))}u.isMDXComponent=!0}}]);