(window.webpackJsonp=window.webpackJsonp||[]).push([[56],{124:function(e,n,i){"use strict";i.r(n),i.d(n,"frontMatter",(function(){return s})),i.d(n,"metadata",(function(){return o})),i.d(n,"rightToc",(function(){return d})),i.d(n,"default",(function(){return b}));var r=i(3),t=i(7),a=(i(0),i(133)),s={title:"Die Liniensensoren",sidebar_label:"Liniensensoren",description:"Die Liniensensoren des Zumo32u4"},o={unversionedId:"zumo32u4/lineSensor",id:"zumo32u4/lineSensor",isDocsHomePage:!1,title:"Die Liniensensoren",description:"Die Liniensensoren des Zumo32u4",source:"@site/docs/zumo32u4/lineSensor.md",slug:"/zumo32u4/lineSensor",permalink:"/docs/zumo32u4/lineSensor",editUrl:"https://spacehal.github.io/docs/zumo32u4/lineSensor.md",version:"current",sidebar_label:"Liniensensoren",sidebar:"sideBarZumo",previous:{title:"Die Taster",permalink:"/docs/zumo32u4/buttons"},next:{title:"Die Motoren",permalink:"/docs/zumo32u4/motors"}},d=[{value:"Einf\xfchrung",id:"einf\xfchrung",children:[]},{value:"Konfigurieren",id:"konfigurieren",children:[{value:"<code>void initThreeSensors()</code>",id:"void-initthreesensors",children:[]},{value:"<code>void initFiveSensors()</code>",id:"void-initfivesensors",children:[]},{value:"<code>void init(...)</code>",id:"void-init",children:[]},{value:"<code>void calibrate()</code>",id:"void-calibrate",children:[]}]},{value:"Messen",id:"messen",children:[{value:"<code>void read(...)</code>",id:"void-read",children:[]},{value:"<code>void readCalibrated(...)</code>",id:"void-readcalibrated",children:[]},{value:"<code>int readLine(...)</code>",id:"int-readline",children:[]}]},{value:"Beispiel f\xfcr die Bestimmung der Linienposition",id:"beispiel-f\xfcr-die-bestimmung-der-linienposition",children:[]}],l={rightToc:d};function b(e){var n=e.components,i=Object(t.a)(e,["components"]);return Object(a.b)("wrapper",Object(r.a)({},l,i,{components:n,mdxType:"MDXLayout"}),Object(a.b)("h2",{id:"einf\xfchrung"},"Einf\xfchrung"),Object(a.b)("p",null,"Der Zumo32u4 hat f\xfcnf unabh\xe4ngige IR-Bodensensoren, welche Linien oder auch Abgr\xfcnde detektieren k\xf6nnen. Die Sensoren befinden sich auf der Unterseite des Roboters, direkt hinter dem Metallschild. "),Object(a.b)("img",{src:"/img/zumo32u4/ZumoLineSensor.jpg",alt:"Liniensensoren des Zumo",width:"500px",class:"center"}),Object(a.b)("p",null," Ein einzelner ",Object(a.b)("a",Object(r.a)({parentName:"p"},{href:"https://www.pololu.com/docs/0J13/all#2"}),"Bodensensor")," bestehen aus einer Reihenschaltung eines ",Object(a.b)("a",Object(r.a)({parentName:"p"},{href:"https://www.pololu.com/file/0J117/QRE1113GR.pdf"}),"Fototransistors")," (welcher vereinfacht als lichtabh\xe4ngiger Widerstand angesehen werden kann) und eines Kondensators. Ist der Kondensator aufgeladen, so h\xe4ngt die Entladekurve vom Fototransistor und somit vom detektierten IR-Licht ab. Wird mit dem Mikrocontroller die Entladezeit des Kondensators gemessen, so kann damit die Menge des detektierten IR-Lichtes bestimmt werden."),Object(a.b)("p",null,"Die Klasse ",Object(a.b)("inlineCode",{parentName:"p"},"Zumo32U4LineSensors")," stellt alle notwendigen Methoden zum Konfigurieren, Auslesen und Weiterverabeiten der 5 IR-Bodensensoren bereit. Sie ist in der Bibliothek des Zumo 32u4 integriert und wird durch den ",Object(a.b)("inlineCode",{parentName:"p"},"include")," Befehl in das Programm eingebunden."),Object(a.b)("pre",null,Object(a.b)("code",Object(r.a)({parentName:"pre"},{className:"language-arduino"}),"#inlcude <Zumo32U4.h>\n")),Object(a.b)("h2",{id:"konfigurieren"},"Konfigurieren"),Object(a.b)("h3",{id:"void-initthreesensors"},Object(a.b)("inlineCode",{parentName:"h3"},"void initThreeSensors()")),Object(a.b)("pre",null,Object(a.b)("code",Object(r.a)({parentName:"pre"},{className:"language-arduino"}),"void initThreeSensors(uint8_t emitterPin = SENSOR_LEDON)\n")),Object(a.b)("p",null,"Initialisiert und konfiguriert das Liniensensor-Objekt so, dass ",Object(a.b)("strong",{parentName:"p"},"drei Sensoren")," (die beiden \xe4u\xdferen und der mittlere) verwendet werden. Kann verwendet werden, wenn auch alle drei N\xe4herungssensoren genutzt werden."),Object(a.b)("h3",{id:"void-initfivesensors"},Object(a.b)("inlineCode",{parentName:"h3"},"void initFiveSensors()")),Object(a.b)("pre",null,Object(a.b)("code",Object(r.a)({parentName:"pre"},{}),"void initFiveSensors(uint8_t emitterPin = SENSOR_LEDON)\n")),Object(a.b)("p",null,"Initialisiert und konfiguriert das Liniensensor-Objekt so, dass ",Object(a.b)("strong",{parentName:"p"},"alle f\xfcnf Sensoren")," verwendet werden. Funktioniert nur, wenn die seitlichen N\xe4herungssensoren deaktiviert wurden. Korrekte Jumper-Einstellung an der Platine der Liniensensoren beachten."),Object(a.b)("h4",{id:"beispiel"},"Beispiel"),Object(a.b)("pre",null,Object(a.b)("code",Object(r.a)({parentName:"pre"},{className:"language-arduino"}),"#inlcude <Zumo32U4.h>\n\nZumo32U4LineSensors lineSensors;    // Liniensensor-Objekt\nvoid setup()\n{\n    lineSensors.initFiveSensors();  \n}\n")),Object(a.b)("h3",{id:"void-init"},Object(a.b)("inlineCode",{parentName:"h3"},"void init(...)")),Object(a.b)("pre",null,Object(a.b)("code",Object(r.a)({parentName:"pre"},{}),"void init (uint8_t *pins, uint8_t\xa0numSensors, uint16_t\xa0timeout = 2000, uint8_t\xa0emitterPin = SENSOR_LEDON\xa0)\n")),Object(a.b)("p",null,"Initialisiert das Liniensensor-Objekt so, dass es einen benutzerdefinierten Satz von ",Object(a.b)("inlineCode",{parentName:"p"},"pins")," verwendet. Meistens sollte die Konfiguration mit  ",Object(a.b)("inlineCode",{parentName:"p"},"void initThreeSensors()")," oder ",Object(a.b)("inlineCode",{parentName:"p"},"void initFiveSensors()")," ausreichen."),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},Object(a.b)("p",{parentName:"li"},"Das Array ",Object(a.b)("inlineCode",{parentName:"p"},"pins")," enth\xe4lt die Arduino-Pin-Nummer f\xfcr jeden Sensor. ")),Object(a.b)("li",{parentName:"ul"},Object(a.b)("p",{parentName:"li"},Object(a.b)("inlineCode",{parentName:"p"},"numSensors")," gibt die L\xe4nge des Arrays ",Object(a.b)("inlineCode",{parentName:"p"},"pins")," an (d.h. die Anzahl der verwendeten Linien-Sensoren).")),Object(a.b)("li",{parentName:"ul"},Object(a.b)("p",{parentName:"li"},Object(a.b)("inlineCode",{parentName:"p"},"timeout")," gibt die Zeitspanne in Mikrosekunden an, nach welcher der Sensor die Fl\xe4che als vollst\xe4ndig schwarz betrachtet. Das hei\xdft, wenn die Impulsl\xe4nge f\xfcr einen Pin die Zeit\xfcberschreitung \xfcberschreitet, wird das Impuls-Timing gestoppt und der Messwert f\xfcr diesen Pin wird als volles Schwarz betrachtet. Es wird empfohlen, dass der Timeout zwischen 1000 und 3000 us eingestellt wird, abh\xe4ngig vom Bodenabstand der Sensoren und der Umgebungsbeleuchtung. Die Verwendung von Timeout erm\xf6glicht es, die Dauer eines Sensorlesezyklus zu verk\xfcrzen und gleichzeitig n\xfctzliche analoge Messungen des Reflexionsgrades beizubehalten.")),Object(a.b)("li",{parentName:"ul"},Object(a.b)("p",{parentName:"li"},Object(a.b)("inlineCode",{parentName:"p"},"emitterPin")," ist der Arduino-Pin, der die IR-LEDs Liniensensoren steuert."))),Object(a.b)("h4",{id:"beispiel-1"},"Beispiel"),Object(a.b)("p",null,"Initialisieren der drei mittleren IR Sensoren."),Object(a.b)("pre",null,Object(a.b)("code",Object(r.a)({parentName:"pre"},{className:"language-arduino"}),"#inlcude <Zumo32U4.h>\n\nZumo32U4LineSensors lineSensors;                            // Liniensensor-Objekt\n\nshort pins[] = {SENSOR_DOWN2, SENSOR_DOWN3, SENSOR_DOWN4}; // Array mit Sensor-Pins\nlineSensors.init(pins, sizeof(pins), 2000, SENSOR_LEDON);  // Initialisierung der Sensoren mit dem vorher definiertem Array \n")),Object(a.b)("h3",{id:"void-calibrate"},Object(a.b)("inlineCode",{parentName:"h3"},"void calibrate()")),Object(a.b)("pre",null,Object(a.b)("code",Object(r.a)({parentName:"pre"},{}),"void calibrate(unsigned char readMode = QTR_EMITTERS_ON)\n")),Object(a.b)("p",null,"Lie\xdft die Sensorwerte f\xfcr ein Kalibrierung. Die beim wiederholden aufrufen der Methode ermittelten Maximal- und Minimalwerte werden f\xfcr jeden Sensor einzeln abgespeichert und bei der Methode ",Object(a.b)("inlineCode",{parentName:"p"},"readCalibrated()")," genutzt. Auf die Kalibrierungsdaten (Minimal- und Maximalwerte der Sensore) kann mit den Pointern ",Object(a.b)("inlineCode",{parentName:"p"},"calibratedMinimumOn"),", ",Object(a.b)("inlineCode",{parentName:"p"},"calibratedMaximumOn")," und ",Object(a.b)("inlineCode",{parentName:"p"},"calibratedMinimumOff"),", ",Object(a.b)("inlineCode",{parentName:"p"},"calibratedMaximumOff")," zugegriffen werden. Dieser Pointer zeigen auf Arrays mit der L\xe4nge ",Object(a.b)("inlineCode",{parentName:"p"},"numSensors"),", wie es bei die Initialisierung angegeben worden ist."),Object(a.b)("p",null,"Die Kalibrierungsdaten werden von den Methoden ",Object(a.b)("a",Object(r.a)({parentName:"p"},{href:"#void-readcalibrated#"}),Object(a.b)("inlineCode",{parentName:"a"},"readCalibrated()"))," und ",Object(a.b)("a",Object(r.a)({parentName:"p"},{href:"#int-readline"}),Object(a.b)("inlineCode",{parentName:"a"},"readLine"),"()")," verwendet."),Object(a.b)("h4",{id:"beispiel-2"},"Beispiel"),Object(a.b)("pre",null,Object(a.b)("code",Object(r.a)({parentName:"pre"},{className:"language-arduino"}),"// Drehen des Roboters um +90\xb0, -180\xb0 und abschlie\xdfend +90\xb0 zum Kalibrieren der Liniensensoren\n\nfor(int i = 0; i < 120; i++)\n  {\n    if (i > 30 && i <= 90)\n    {\n      motors.setSpeeds(-200, 200);\n    }\n    else\n    {\n      motors.setSpeeds(200, -200);\n    }\n    lineSensors.calibrate();  // Kalibrierungsmethode\n  }\n  motors.setSpeeds(0, 0);\n}\n")),Object(a.b)("h2",{id:"messen"},"Messen"),Object(a.b)("h3",{id:"void-read"},Object(a.b)("inlineCode",{parentName:"h3"},"void read(...)")),Object(a.b)("pre",null,Object(a.b)("code",Object(r.a)({parentName:"pre"},{}),"void read(unsigned int *sensor_values, unsigned char readMode=QTR_EMITTERS_ON)\n")),Object(a.b)("p",null,"Liest die rohen, unkalibrierten Sensorwerte in einen Array ",Object(a.b)("inlineCode",{parentName:"p"},"sensor_values"),". Es ",Object(a.b)("strong",{parentName:"p"},"muss")," Platz f\xfcr so viele Werte vorhanden sein, wie bei der Initialisierung an Sensoren angegeben wurden.\nDie zur\xfcckgegebenen Werte sind ein Ma\xdf f\xfcr den Reflexionsgrad in abstrakten Einheiten, wobei h\xf6here Werte einem niedrigeren Reflexionsgrad entsprechen (z.B. eine schwarze Fl\xe4che oder ein Hohlraum). "),Object(a.b)("h4",{id:"beispiel-3"},"Beispiel"),Object(a.b)("pre",null,Object(a.b)("code",Object(r.a)({parentName:"pre"},{className:"language-arduino"}),"Zumo32U4LineSensors lineSensors;       // Liniensensor-Objekt\n\nunsigned int lineSensorValues[3];      // Array f\xfcr drei Sensorwerte\nlineSensors.read(lineSensorValues);    // Array f\xfcr die Sensorwerte wird \xfcberschrieben\n")),Object(a.b)("h3",{id:"void-readcalibrated"},Object(a.b)("inlineCode",{parentName:"h3"},"void readCalibrated(...)")),Object(a.b)("pre",null,Object(a.b)("code",Object(r.a)({parentName:"pre"},{}),"void readCalibrated(unsigned int *sensor_values, unsigned char readMode=QTR_EMITTERS_ON)\n")),Object(a.b)("p",null,"Liefert Werte, die auf einen Wert zwischen 0 und 1000 kalibriert sind, wobei 0 dem von ",Object(a.b)("a",Object(r.a)({parentName:"p"},{href:"#void-calibrate"}),Object(a.b)("inlineCode",{parentName:"a"},"void calibrate()"))," gelesenen Minimalwert entspricht und 1000 dem Maximalwert entspricht.  Die Kalibrierungswerte werden f\xfcr jeden Sensor separat gespeichert, so dass Unterschiede in den Sensoren automatisch ber\xfccksichtigt werden. Vor dem Aufruf der Methode sollte immer eine Kalibrierung mit ",Object(a.b)("a",Object(r.a)({parentName:"p"},{href:"#void-calibrate"}),Object(a.b)("inlineCode",{parentName:"a"},"void calibrate()"))," durchgef\xfchrt werden."),Object(a.b)("h4",{id:"beispiel-4"},"Beispiel"),Object(a.b)("pre",null,Object(a.b)("code",Object(r.a)({parentName:"pre"},{className:"language-arduino"}),"#define NUM_SENSORS 3\nZumo32U4LineSensors lineSensors;              // Liniensensor-Objekt\n\nunsigned int lineSensorValues[NUM_SENSORS];   // Array f\xfcr die Sensorwerte\nlineSensors.readCalibrated(lineSensorValues); // Array f\xfcr die Sensorwerte wird \xfcberschrieben\n")),Object(a.b)("h3",{id:"int-readline"},Object(a.b)("inlineCode",{parentName:"h3"},"int readLine(...)")),Object(a.b)("pre",null,Object(a.b)("code",Object(r.a)({parentName:"pre"},{}),"int readLine(unsigned int *sensor_values, unsigned char readMode=QTR_EMITTERS_ON, unsigned char white_line=0)\n")),Object(a.b)("p",null,"Funktioniert wie ",Object(a.b)("inlineCode",{parentName:"p"},"readCalibrated()"),", gibt aber auch eine gesch\xe4tzte Position des Roboters in Bezug auf eine Linie zur\xfcck. Die Sch\xe4tzung erfolgt unter Verwendung eines ",Object(a.b)("a",Object(r.a)({parentName:"p"},{href:"https://de.wikipedia.org/wiki/Gewichtung"}),"gewichteten Mittelwerts"),", welcher die Sensorwerte mit Vielfachen von 1000 multipliziert, so dass ein R\xfcckgabewert von 0 anzeigt, dass die Zeile direkt unter Sensor 0 liegt, ein R\xfcckgabewert von 1000 zeigt an, dass die Zeile direkt unter Sensor 1 liegt, 2000 zeigt an, dass sie unter Sensor 2000 liegt, usw.  Zwischenwerte zeigen an, dass sich die Linie zwischen zwei Sensoren befindet. Die Formel lautet : $$ \\frac{0\\cdot x_0 + 1000\\cdot x_1 + 2000 \\cdot x_2 +\\cdots}{x_0 + x_1 + x_2 + \\cdots} $$ "),Object(a.b)("p",null,"Standardm\xe4\xdfig geht diese Funktion von einer dunklen Linie (hohe Werte) aus, die von Wei\xdf (niedrige Werte) umgeben ist.  Wenn die verwendete Linie hell auf Schwarz ist, setzen Sie das optionale zweite Argument ",Object(a.b)("inlineCode",{parentName:"p"},"white_line")," auf ",Object(a.b)("inlineCode",{parentName:"p"},"true"),".  In diesem Fall wird jeder Sensorwert vor der Mittelung durch (1000 - Wert) ersetzt."),Object(a.b)("h4",{id:"beispiel-5"},"Beispiel"),Object(a.b)("pre",null,Object(a.b)("code",Object(r.a)({parentName:"pre"},{className:"language-arduino"}),"#define NUM_SENSORS 5\nZumo32U4LineSensors lineSensors;              // Liniensensor-Objekt\n\nunsigned int lineSensorValues[NUM_SENSORS];   // Array f\xfcr die Sensorwerte\nint position = lineSensors.readLine(lineSensorValues);\n")),Object(a.b)("h2",{id:"beispiel-f\xfcr-die-bestimmung-der-linienposition"},"Beispiel f\xfcr die Bestimmung der Linienposition"),Object(a.b)("pre",null,Object(a.b)("code",Object(r.a)({parentName:"pre"},{className:"language-arduino"}),'/*\n   Liniensensor-Demo mit alle f\xfcnf Boden Sensoren\n*/\n\n#include <Zumo32U4.h>\n\nZumo32U4LineSensors lineSensors;\nZumo32U4ButtonA buttonA;\nZumo32U4Motors motors;\nZumo32U4LCD lcd;\n\n\n#define NUM_SENSORS 5                       // Anzahl der verwendeten Sensoren\nunsigned int lineSensorValues[NUM_SENSORS]; // Array f\xfcr die Sensorwerte\n\nint timeStamp = 0;\n\n// Eine Sekunde warten und dann beginnen mit der Kalibirierung der Bodensensoren\n// durch automatisches Drehen des Roboters um etwa -90, +180, -90 Grad.\nvoid calibrateSensors()\n{\n  lcd.clear();\n  lcd.print(F("Calib ..."));\n  delay(1000);\n\n  // Kalibirierungsschleife: Roboter dreht sich und nimmt 120 Messwerte auf\n  for (int i = 0; i < 120; i++)\n  {\n    if (i > 30 && i <= 90){\n      motors.setSpeeds(-200, 200);\n    }\n    else{\n      motors.setSpeeds(200, -200);\n    } \n\n    lineSensors.calibrate();  // Sensoren auswerten und kalibrieren\n  }\n  motors.setSpeeds(0, 0);\n  lcd.clear();\n}\n\nvoid setup() {\n  lineSensors.initFiveSensors();    // Bodensensoren initialisieren\n\n  // "Welcome"-Anzeige auf dem Display\n  lcd.clear();\n  lcd.gotoXY(0, 0); lcd.print(F("LineDemo"));\n  lcd.gotoXY(0, 1); lcd.print(F("-> A"));\n  buttonA.waitForPress();\n  lcd.clear();\n\n  calibrateSensors();\n}\n\nvoid loop() {\n  \n  int updateTime = 333;\n\n  // alle 0.33 ms auswerten der Sensoren und aktualisieren des Display\n  if ( (millis() - timeStamp) > updateTime){\n    int position = lineSensors.readLine(lineSensorValues);\n    lcd.gotoXY(0,0);\n    lcd.print(position);\n    lcd.print(F("   "));  \n  }\n}\n')))}b.isMDXComponent=!0},133:function(e,n,i){"use strict";i.d(n,"a",(function(){return c})),i.d(n,"b",(function(){return m}));var r=i(0),t=i.n(r);function a(e,n,i){return n in e?Object.defineProperty(e,n,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[n]=i,e}function s(e,n){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),i.push.apply(i,r)}return i}function o(e){for(var n=1;n<arguments.length;n++){var i=null!=arguments[n]?arguments[n]:{};n%2?s(Object(i),!0).forEach((function(n){a(e,n,i[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):s(Object(i)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(i,n))}))}return e}function d(e,n){if(null==e)return{};var i,r,t=function(e,n){if(null==e)return{};var i,r,t={},a=Object.keys(e);for(r=0;r<a.length;r++)i=a[r],n.indexOf(i)>=0||(t[i]=e[i]);return t}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)i=a[r],n.indexOf(i)>=0||Object.prototype.propertyIsEnumerable.call(e,i)&&(t[i]=e[i])}return t}var l=t.a.createContext({}),b=function(e){var n=t.a.useContext(l),i=n;return e&&(i="function"==typeof e?e(n):o(o({},n),e)),i},c=function(e){var n=b(e.components);return t.a.createElement(l.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return t.a.createElement(t.a.Fragment,{},n)}},p=t.a.forwardRef((function(e,n){var i=e.components,r=e.mdxType,a=e.originalType,s=e.parentName,l=d(e,["components","mdxType","originalType","parentName"]),c=b(i),p=r,m=c["".concat(s,".").concat(p)]||c[p]||u[p]||a;return i?t.a.createElement(m,o(o({ref:n},l),{},{components:i})):t.a.createElement(m,o({ref:n},l))}));function m(e,n){var i=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var a=i.length,s=new Array(a);s[0]=p;var o={};for(var d in n)hasOwnProperty.call(n,d)&&(o[d]=n[d]);o.originalType=e,o.mdxType="string"==typeof e?e:r,s[1]=o;for(var l=2;l<a;l++)s[l]=i[l];return t.a.createElement.apply(null,s)}return t.a.createElement.apply(null,i)}p.displayName="MDXCreateElement"}}]);