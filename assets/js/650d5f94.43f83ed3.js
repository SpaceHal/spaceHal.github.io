"use strict";(self.webpackChunkspace_hal_2=self.webpackChunkspace_hal_2||[]).push([[483],{3905:function(e,n,r){r.d(n,{Zo:function(){return d},kt:function(){return p}});var i=r(67294);function t(e,n,r){return n in e?Object.defineProperty(e,n,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[n]=r,e}function a(e,n){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);n&&(i=i.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),r.push.apply(r,i)}return r}function u(e){for(var n=1;n<arguments.length;n++){var r=null!=arguments[n]?arguments[n]:{};n%2?a(Object(r),!0).forEach((function(n){t(e,n,r[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):a(Object(r)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(r,n))}))}return e}function o(e,n){if(null==e)return{};var r,i,t=function(e,n){if(null==e)return{};var r,i,t={},a=Object.keys(e);for(i=0;i<a.length;i++)r=a[i],n.indexOf(r)>=0||(t[r]=e[r]);return t}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(i=0;i<a.length;i++)r=a[i],n.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(t[r]=e[r])}return t}var l=i.createContext({}),s=function(e){var n=i.useContext(l),r=n;return e&&(r="function"==typeof e?e(n):u(u({},n),e)),r},d=function(e){var n=s(e.components);return i.createElement(l.Provider,{value:n},e.children)},g={inlineCode:"code",wrapper:function(e){var n=e.children;return i.createElement(i.Fragment,{},n)}},c=i.forwardRef((function(e,n){var r=e.components,t=e.mdxType,a=e.originalType,l=e.parentName,d=o(e,["components","mdxType","originalType","parentName"]),c=s(r),p=t,m=c["".concat(l,".").concat(p)]||c[p]||g[p]||a;return r?i.createElement(m,u(u({ref:n},d),{},{components:r})):i.createElement(m,u({ref:n},d))}));function p(e,n){var r=arguments,t=n&&n.mdxType;if("string"==typeof e||t){var a=r.length,u=new Array(a);u[0]=c;var o={};for(var l in n)hasOwnProperty.call(n,l)&&(o[l]=n[l]);o.originalType=e,o.mdxType="string"==typeof e?e:t,u[1]=o;for(var s=2;s<a;s++)u[s]=r[s];return i.createElement.apply(null,u)}return i.createElement.apply(null,r)}c.displayName="MDXCreateElement"},58563:function(e,n,r){r.r(n),r.d(n,{frontMatter:function(){return u},contentTitle:function(){return o},metadata:function(){return l},toc:function(){return s},default:function(){return g}});var i=r(87462),t=r(63366),a=(r(67294),r(3905)),u={title:"Auf einer Linie mit Kreuzungen und Abzweigungen navigieren",sidebar_label:"Linie mit Kreuzungen",description:"Ein fortgeschrittener Linienfolger der Kreuzungen, Abzweigungen und Sackgassen erkennt und sein Verhalten automatisch anpasst.",custom_edit_url:null,keywords:["Arduino","Linenfolger","Kantenfolge","Roboter","Robotik","Kreuzungen","Hindernis","Abbiegen"]},o=void 0,l={unversionedId:"robotik/advancedLine",id:"robotik/advancedLine",isDocsHomePage:!1,title:"Auf einer Linie mit Kreuzungen und Abzweigungen navigieren",description:"Ein fortgeschrittener Linienfolger der Kreuzungen, Abzweigungen und Sackgassen erkennt und sein Verhalten automatisch anpasst.",source:"@site/docs/robotik/advancedLine.md",sourceDirName:"robotik",slug:"/robotik/advancedLine",permalink:"/docs/robotik/advancedLine",editUrl:null,tags:[],version:"current",lastUpdatedAt:1631966711,formattedLastUpdatedAt:"18.9.2021",frontMatter:{title:"Auf einer Linie mit Kreuzungen und Abzweigungen navigieren",sidebar_label:"Linie mit Kreuzungen",description:"Ein fortgeschrittener Linienfolger der Kreuzungen, Abzweigungen und Sackgassen erkennt und sein Verhalten automatisch anpasst.",custom_edit_url:null,keywords:["Arduino","Linenfolger","Kantenfolge","Roboter","Robotik","Kreuzungen","Hindernis","Abbiegen"]},sidebar:"sideBarRobotik",previous:{title:"PD-Regler",permalink:"/docs/robotik/lineFollowerPID"},next:{title:"Rad-Encoder",permalink:"/docs/robotik/wheelEncoder"}},s=[{value:"Auf einer Linie mit Kreuzungen navigieren",id:"auf-einer-linie-mit-kreuzungen-navigieren",children:[{value:"Hauptprogramm <code>void loop()</code>",id:"hauptprogramm-void-loop",children:[]},{value:"Funktion <code>istKreuzung()</code>",id:"funktion-istkreuzung",children:[]},{value:"Funktion <code>reagierenKreuzung()</code>",id:"funktion-reagierenkreuzung",children:[]}]},{value:"Hilfsfunktion zum Debuggen",id:"hilfsfunktion-zum-debuggen",children:[{value:"<code>sprintf()</code>",id:"sprintf",children:[]}]}],d={toc:s};function g(e){var n=e.components,r=(0,t.Z)(e,["components"]);return(0,a.kt)("wrapper",(0,i.Z)({},d,r,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"Das Folgen einer Linie mit Kreuzungen, Unterbrechungen oder \xc4hnlichem erh\xf6ht die Komplexit\xe4t des Linienfolgers. "),(0,a.kt)("p",null,"Neben dem Regler f\xfcr den Linienfolger muss der Roboter zus\xe4tzlich noch so programmiert werden, dass er regelm\xe4\xdfig ",(0,a.kt)("strong",{parentName:"p"},"\xfcberpr\xfcft"),", ob er sich gerade ",(0,a.kt)("strong",{parentName:"p"},"\xfcber einer Kreuzung oder Unterbrechung befindet"),". Hat der Roboter ein Hindernis erkannt, muss er abh\xe4ngig vom Hindernis eine vorher ",(0,a.kt)("strong",{parentName:"p"},"festgelegte Aktion")," (",(0,a.kt)("em",{parentName:"p"},"links abbiegen, rechts abbiegen, weiterfahren, etc."),") ",(0,a.kt)("strong",{parentName:"p"},"ausf\xfchren"),"."),(0,a.kt)("p",null,"Im Folgenden sind ein paar Anregungen zum Erkennen einer Kreuzung oder zum geschicketen Reagieren auf Kreuzungen aufgef\xfchrt. Es handelt sich hier nicht um eine vollst\xe4ndige L\xf6sung des Problems, sondern vielmehr um m\xf6gliche Ans\xe4tze f\xfcr eigene Realisierungen."),(0,a.kt)("h2",{id:"auf-einer-linie-mit-kreuzungen-navigieren"},"Auf einer Linie mit Kreuzungen navigieren"),(0,a.kt)("img",{src:"/img/robotik/AdvancedParcour.png",alt:"Advanced line follower track with intersections",width:"500px",class:"center"}),(0,a.kt)("div",{className:"admonition admonition-caution alert alert--warning"},(0,a.kt)("div",{parentName:"div",className:"admonition-heading"},(0,a.kt)("h5",{parentName:"div"},(0,a.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,a.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"16",height:"16",viewBox:"0 0 16 16"},(0,a.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z"}))),"caution")),(0,a.kt)("div",{parentName:"div",className:"admonition-content"},(0,a.kt)("p",{parentName:"div"},"Hinweis: Die Nummerierung der Kreuzungen und \xe4hnlichem ist nur bedingt vollst\xe4ndig. Abh\xe4ngig vom Verhalten des Roboters kann es notwendig sein, auch andere markante Stellen als Kreuzungen zu betrachten."))),(0,a.kt)("h3",{id:"hauptprogramm-void-loop"},"Hauptprogramm ",(0,a.kt)("inlineCode",{parentName:"h3"},"void loop()")),(0,a.kt)("p",null,"Im Hauptprogramm des fortgeschrittenen Linienfolgers sollte zum einen der Regler zum Linienfolgen (",(0,a.kt)("inlineCode",{parentName:"p"},"folgeLine()"),") aufgerufen werden, zum andern aber auch Kreuzungen u.\xe4. erkannt und darauf reagiert werden."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-arduino",metastring:"{6,10-13}","{6,10-13}":!0},'int aktuelleKreuzung = 0;\n\nvoid loop() {\n  if (!istKreuzung())                       // keine Kreuzung, also Linie\n  { \n    folgeLine();                            // Regler zum Linienfolgen\n  }\n  else                                      // Kreuzung (oder \xe4hnlich) erkannt\n  {  \n    aktuelleKreuzung++;                     // Z\xe4hlvariable f\xfcr die Kreuzungen\n    if (aktuelleKreuzung < 12) {\n      reagierenKreuzung(aktuelleKreuzung);  // Abh\xe4ngig vom Hindernis abbiegen, weiterfahren, etc. \n    }\n    else  {                                 // letzte  Kreuzung ist erreicht\n      motors.setSpeeds(0, 0);   \n      lcd.print(" -ENDE- ");\n    }\n  }\n}\n')),(0,a.kt)("p",null,"Im oben dargestellten ",(0,a.kt)("strong",{parentName:"p"},"Beispielcode")," wird in der ersten if-Abfrage die Funktion ",(0,a.kt)("a",{parentName:"p",href:"#funktion-istkreuzung"},(0,a.kt)("inlineCode",{parentName:"a"},"istKreuzung()"))," aufgerufen. Die Funktion ",(0,a.kt)("inlineCode",{parentName:"p"},"istKreuzung()")," sollte ",(0,a.kt)("inlineCode",{parentName:"p"},"true")," zur\xfcckgibt, sobald sich der Roboter \xfcber einer Kreuzung oder \xe4hnlichem befindet. Da in der if-Abfrage die Aussage mit ",(0,a.kt)("inlineCode",{parentName:"p"},"!")," negiert wird, folgt der Roboter so lange der Linie mit dem Befehl ",(0,a.kt)("inlineCode",{parentName:"p"},"folgeLine()"),", wie sich der Roboter ",(0,a.kt)("strong",{parentName:"p"},"nicht")," auf einer Kreuzung befindet."),(0,a.kt)("p",null,"Wurde eine Kreuzung erkannt, wird der ",(0,a.kt)("inlineCode",{parentName:"p"},"else")," Zweig aufgerufen und die Z\xe4hlvariable ",(0,a.kt)("inlineCode",{parentName:"p"},"aktuelleKreuzung")," f\xfcr die aktuelle Kreuzung um eins erh\xf6ht. Die Z\xe4hlvariable wird, nachdem \xfcberpr\xfcft w\xfcrde, ob die letzte Kreuzung noch nicht erreicht wurde (",(0,a.kt)("inlineCode",{parentName:"p"},"if (aktuelleKreuzung < 12)"),"), als Argument f\xfcr die Funktion ",(0,a.kt)("a",{parentName:"p",href:"#funktion-reagierenkreuzung"},(0,a.kt)("inlineCode",{parentName:"a"},"reagierenKreuzung(int aktuelleKreuzung)"))," verwendet."),(0,a.kt)("p",null,"In der Funktion ",(0,a.kt)("inlineCode",{parentName:"p"},"reagierenKreuzung(int aktuelleKreuzung)")," sollte mit einer ",(0,a.kt)("inlineCode",{parentName:"p"},"switch"),"-",(0,a.kt)("inlineCode",{parentName:"p"},"case"),"-Anweisung oder \xe4hnlichem f\xfcr jede Kreuzungsnummer eine Anweisung hinterlegt sein, wie sich der Roboter an entsprechender Stelle zu verhalten hat (",(0,a.kt)("em",{parentName:"p"},"links abbiegen, rechts abbiegen, weiterfahren, etc."),")."),(0,a.kt)("h3",{id:"funktion-istkreuzung"},"Funktion ",(0,a.kt)("inlineCode",{parentName:"h3"},"istKreuzung()")),(0,a.kt)("p",null,"Die Funktion ",(0,a.kt)("inlineCode",{parentName:"p"},"bool istKreuzung()")," soll nur erkennen, ob sich der Roboter \xfcber einer Linie befindet und einen entsprechenden boolschen Wert zur\xfcckgeben. Daf\xfcr reicht es aus, die einzelnen Sensorwerte mit einem Schwellwert (z.B. 500) zu vergleichen und sich f\xfcr die einzelnen Sensoren eine geeignete Bedingung zum Erkennen einer Kreuzung zu \xfcberlegen."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"// Gibt `true` (1) zur\xfcck, wenn der angegebene Sensor eine Linie detektiert.\nbool isSensorBlack(byte sensorIndex) {\n  const int lineThreshold = 400;\n  return lineSensorValues[sensorIndex] > lineThreshold;\n}\n")),(0,a.kt)("h3",{id:"funktion-reagierenkreuzung"},"Funktion ",(0,a.kt)("inlineCode",{parentName:"h3"},"reagierenKreuzung()")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"#define LINKS 1\n#define RECHTS 2\n\nvoid reagierenKreuzung(int pKreuzNummer) {\n  // F\xfcr jede Kreuzung wird die zugeh\xf6rige Aktion als `case` hinterlegt.\n  switch (pKreuzNummer) {\n    case 1: \n    case 2: \n      drehenLinksRechts(RECHTS);\n      break;\n\n    case 3:\n      fahrenWueste();\n      break;\n\n    // Weitere Anweisungen ...\n\n  }\n}\n")),(0,a.kt)("h2",{id:"hilfsfunktion-zum-debuggen"},"Hilfsfunktion zum Debuggen"),(0,a.kt)("p",null,"Die Hilfsfunktion ",(0,a.kt)("inlineCode",{parentName:"p"},"showIntersectionReadings()")," gibt auf dem Display zuerst die Sensorwerte des ganz linken und ganz rechten Sensors aus. Nach vier Sekunden wird die Anzeige ge\xe4ndert, und die Werte des mittleren Sensors und die Position der Linie wird ausgegeben."),(0,a.kt)("p",null,"Verwenden Sie die Funktion zum Testen, ob der Roboter an den Kreuzungen auch wirklich das erkennt, was sie vermuten. Nutzen Sie die, oder eine \xe4hnliche Funktion, lieber einmal zu viel als zu wenig. Es kann Ihnen viel M\xfche und Kopfzerbrechen ersparen."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-arduino"},'void showIntersectionReadings() {\n  char msg1[8];\n  char msg2[8];\n\n  delay(1000);\n  int lPosition = lineSensors.readLine(lineSensorValues); // aktualisiere der Sensorwertee\n\n\n  sprintf(msg1, "0: %4d", lineSensorValues[0]); // Sensor ganz links\n  lcd.gotoXY(0, 0); lcd.print(msg1);\n  sprintf(msg2, "4: %4d", lineSensorValues[4]); // Sensor ganz rechts\n  lcd.gotoXY(0, 1); lcd.print(msg2);\n  delay(4000);\n\n  sprintf(msg1, "2:  %4d", lineSensorValues[2]);  // Sensor mitte\n  lcd.gotoXY(0, 0); lcd.print(msg1);\n  sprintf(msg2, "Pos %4d", lPosition);           // Positin der Linie\n  lcd.gotoXY(0, 1); lcd.print(msg2);\n  delay(4000);\n  lcd.clear();\n}\n')),(0,a.kt)("p",null,"Zum Ausgeben der Werte auf dem Display wird die Funktion ",(0,a.kt)("inlineCode",{parentName:"p"},"sprintf()")," genutzt. Die Funktion erlaubt es Text und Zahlenwerte nach bestimmten Regeln zu formatieren und ein eine neue Variable (hier den ",(0,a.kt)("inlineCode",{parentName:"p"},"char"),"-Array ",(0,a.kt)("inlineCode",{parentName:"p"},"msg1[]")," oder ",(0,a.kt)("inlineCode",{parentName:"p"},"msg2[]")," zu schreiben und anschlie\xdfend mit ",(0,a.kt)("inlineCode",{parentName:"p"},"lcd.print(msg1)")," auf dem LCD-Display auszugeben."),(0,a.kt)("h3",{id:"sprintf"},(0,a.kt)("inlineCode",{parentName:"h3"},"sprintf()")),(0,a.kt)("p",null,"Das Prozentzeihen ",(0,a.kt)("inlineCode",{parentName:"p"},"%")," markiert einen Platzhalter f\xfcr Zahlenwerte, die formatiert werden sollen. So wird zum Beispiel mit ",(0,a.kt)("inlineCode",{parentName:"p"},"%4d")," ein Integerwert ausgeben und nach links Platz f\xfcr 4 Stellen bereitgestellt. Hat der Integerwert weniger als 4 Stellen, so wird an der Stelle ein Leerzeichen ausgegeben. Siehe auch ",(0,a.kt)("a",{parentName:"p",href:"https://de.wikibooks.org/wiki/C-Programmierung:_Einfache_Ein-_und_Ausgabe"},"hier"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-Arduino"},"int wert1 = 80;\nsprintf(msg1, \"Wert:%4d\", wert1); //\n// Ausgabe: 'Num:  80'\nint wert1 = 1280;\nsprintf(msg1, \"Num:%4d\", wert2);\n// Ausgabe: 'Wert:2280'\n")),(0,a.kt)("div",{className:"admonition admonition-caution alert alert--warning"},(0,a.kt)("div",{parentName:"div",className:"admonition-heading"},(0,a.kt)("h5",{parentName:"div"},(0,a.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,a.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"16",height:"16",viewBox:"0 0 16 16"},(0,a.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z"}))),"caution")),(0,a.kt)("div",{parentName:"div",className:"admonition-content"},(0,a.kt)("p",{parentName:"div"}," Das LCD-Display des Zumo 32u4 hat pro Zeil nur 8 Zeichen. Also sollten nicht mehr als 8 Zeichen pro Zeile ausgegeben werden."))))}g.isMDXComponent=!0}}]);