"use strict";(self.webpackChunkspace_hal=self.webpackChunkspace_hal||[]).push([[1637],{3905:(e,n,t)=>{t.d(n,{Zo:()=>u,kt:()=>k});var i=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);n&&(i=i.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,i)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?a(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,i,r=function(e,n){if(null==e)return{};var t,i,r={},a=Object.keys(e);for(i=0;i<a.length;i++)t=a[i],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(i=0;i<a.length;i++)t=a[i],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var d=i.createContext({}),o=function(e){var n=i.useContext(d),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},u=function(e){var n=o(e.components);return i.createElement(d.Provider,{value:n},e.children)},p="mdxType",m={inlineCode:"code",wrapper:function(e){var n=e.children;return i.createElement(i.Fragment,{},n)}},c=i.forwardRef((function(e,n){var t=e.components,r=e.mdxType,a=e.originalType,d=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),p=o(t),c=r,k=p["".concat(d,".").concat(c)]||p[c]||m[c]||a;return t?i.createElement(k,l(l({ref:n},u),{},{components:t})):i.createElement(k,l({ref:n},u))}));function k(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var a=t.length,l=new Array(a);l[0]=c;var s={};for(var d in n)hasOwnProperty.call(n,d)&&(s[d]=n[d]);s.originalType=e,s[p]="string"==typeof e?e:r,l[1]=s;for(var o=2;o<a;o++)l[o]=t[o];return i.createElement.apply(null,l)}return i.createElement.apply(null,t)}c.displayName="MDXCreateElement"},5162:(e,n,t)=>{t.d(n,{Z:()=>l});var i=t(7294),r=t(6010);const a={tabItem:"tabItem_Ymn6"};function l(e){let{children:n,hidden:t,className:l}=e;return i.createElement("div",{role:"tabpanel",className:(0,r.Z)(a.tabItem,l),hidden:t},n)}},4866:(e,n,t)=>{t.d(n,{Z:()=>N});var i=t(7462),r=t(7294),a=t(6010),l=t(2466),s=t(6550),d=t(1980),o=t(7392),u=t(12);function p(e){return function(e){return r.Children.map(e,(e=>{if(!e||(0,r.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}(e).map((e=>{let{props:{value:n,label:t,attributes:i,default:r}}=e;return{value:n,label:t,attributes:i,default:r}}))}function m(e){const{values:n,children:t}=e;return(0,r.useMemo)((()=>{const e=n??p(t);return function(e){const n=(0,o.l)(e,((e,n)=>e.value===n.value));if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[n,t])}function c(e){let{value:n,tabValues:t}=e;return t.some((e=>e.value===n))}function k(e){let{queryString:n=!1,groupId:t}=e;const i=(0,s.k6)(),a=function(e){let{queryString:n=!1,groupId:t}=e;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!t)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return t??null}({queryString:n,groupId:t});return[(0,d._X)(a),(0,r.useCallback)((e=>{if(!a)return;const n=new URLSearchParams(i.location.search);n.set(a,e),i.replace({...i.location,search:n.toString()})}),[a,i])]}function b(e){const{defaultValue:n,queryString:t=!1,groupId:i}=e,a=m(e),[l,s]=(0,r.useState)((()=>function(e){let{defaultValue:n,tabValues:t}=e;if(0===t.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(n){if(!c({value:n,tabValues:t}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${n}" but none of its children has the corresponding value. Available values are: ${t.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return n}const i=t.find((e=>e.default))??t[0];if(!i)throw new Error("Unexpected error: 0 tabValues");return i.value}({defaultValue:n,tabValues:a}))),[d,o]=k({queryString:t,groupId:i}),[p,b]=function(e){let{groupId:n}=e;const t=function(e){return e?`docusaurus.tab.${e}`:null}(n),[i,a]=(0,u.Nk)(t);return[i,(0,r.useCallback)((e=>{t&&a.set(e)}),[t,a])]}({groupId:i}),g=(()=>{const e=d??p;return c({value:e,tabValues:a})?e:null})();(0,r.useLayoutEffect)((()=>{g&&s(g)}),[g]);return{selectedValue:l,selectValue:(0,r.useCallback)((e=>{if(!c({value:e,tabValues:a}))throw new Error(`Can't select invalid tab value=${e}`);s(e),o(e),b(e)}),[o,b,a]),tabValues:a}}var g=t(2389);const h={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};function f(e){let{className:n,block:t,selectedValue:s,selectValue:d,tabValues:o}=e;const u=[],{blockElementScrollPositionUntilNextRender:p}=(0,l.o5)(),m=e=>{const n=e.currentTarget,t=u.indexOf(n),i=o[t].value;i!==s&&(p(n),d(i))},c=e=>{let n=null;switch(e.key){case"Enter":m(e);break;case"ArrowRight":{const t=u.indexOf(e.currentTarget)+1;n=u[t]??u[0];break}case"ArrowLeft":{const t=u.indexOf(e.currentTarget)-1;n=u[t]??u[u.length-1];break}}n?.focus()};return r.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,a.Z)("tabs",{"tabs--block":t},n)},o.map((e=>{let{value:n,label:t,attributes:l}=e;return r.createElement("li",(0,i.Z)({role:"tab",tabIndex:s===n?0:-1,"aria-selected":s===n,key:n,ref:e=>u.push(e),onKeyDown:c,onClick:m},l,{className:(0,a.Z)("tabs__item",h.tabItem,l?.className,{"tabs__item--active":s===n})}),t??n)})))}function L(e){let{lazy:n,children:t,selectedValue:i}=e;const a=(Array.isArray(t)?t:[t]).filter(Boolean);if(n){const e=a.find((e=>e.props.value===i));return e?(0,r.cloneElement)(e,{className:"margin-top--md"}):null}return r.createElement("div",{className:"margin-top--md"},a.map(((e,n)=>(0,r.cloneElement)(e,{key:n,hidden:e.props.value!==i}))))}function w(e){const n=b(e);return r.createElement("div",{className:(0,a.Z)("tabs-container",h.tabList)},r.createElement(f,(0,i.Z)({},e,n)),r.createElement(L,(0,i.Z)({},e,n)))}function N(e){const n=(0,g.Z)();return r.createElement(w,(0,i.Z)({key:String(n)},e))}},3013:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>u,contentTitle:()=>d,default:()=>k,frontMatter:()=>s,metadata:()=>o,toc:()=>p});var i=t(7462),r=(t(7294),t(3905)),a=t(4866),l=t(5162);const s={title:"Einfache Objektorientierung mit Arduino",sidebar_label:"Objektorientierung",description:"Objektorientierte Programmierung (OOP) beim Arduino. Wie mit Klassen und Objekten Multitasking realisiert werden kann.",custom_edit_url:null,keywords:["Arduino","Arduino Klassen","Multitasking","objektorientiert","Klassen","Objekte","Blinken","LED","OOP","OO Programmierung"]},d=void 0,o={unversionedId:"arduino/objectOriented",id:"arduino/objectOriented",title:"Einfache Objektorientierung mit Arduino",description:"Objektorientierte Programmierung (OOP) beim Arduino. Wie mit Klassen und Objekten Multitasking realisiert werden kann.",source:"@site/docs/arduino/objectOriented.md",sourceDirName:"arduino",slug:"/arduino/objectOriented",permalink:"/docs/arduino/objectOriented",draft:!1,editUrl:null,tags:[],version:"current",frontMatter:{title:"Einfache Objektorientierung mit Arduino",sidebar_label:"Objektorientierung",description:"Objektorientierte Programmierung (OOP) beim Arduino. Wie mit Klassen und Objekten Multitasking realisiert werden kann.",custom_edit_url:null,keywords:["Arduino","Arduino Klassen","Multitasking","objektorientiert","Klassen","Objekte","Blinken","LED","OOP","OO Programmierung"]},sidebar:"mySidebar",previous:{title:"Men\xfcsteuerung",permalink:"/docs/arduino/simpleMenu"},next:{title:"OLED Display",permalink:"/docs/arduino/oled"}},u={},p=[{value:"Beispiel einer LED-Klasse",id:"beispiel-einer-led-klasse",level:2},{value:"Klassendefinition",id:"klassendefinition",level:3},{value:"Konstruktor",id:"konstruktor",level:3},{value:"Methode zum Umschalten",id:"methode-zum-umschalten",level:3},{value:"Das vollst\xe4ndige Programm",id:"das-vollst\xe4ndige-programm",level:3},{value:"Wie nutze ich Tabs mit Klassen",id:"wie-nutze-ich-tabs-mit-klassen",level:2},{value:"Ein Array mit Objekten",id:"ein-array-mit-objekten",level:2},{value:"Links",id:"links",level:2}],m={toc:p},c="wrapper";function k(e){let{components:n,...t}=e;return(0,r.kt)(c,(0,i.Z)({},m,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("head",null,(0,r.kt)("link",{rel:"canonical",href:"https://spacehal.github.io/docs/arduino/objectOriented"})),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Klassen")," und ",(0,r.kt)("strong",{parentName:"p"},"Objekte")," stellen eine Weiterentwicklung des Konzeptes von Variablen und Funktionen dar. W\xe4hrend eine Variable nur einen Wert (oder als ",(0,r.kt)("a",{parentName:"p",href:"/docs/arduino/array"},"Array")," auch mehrere Werte) besitzen kann, so kann ",(0,r.kt)("strong",{parentName:"p"},"ein Objekt zus\xe4tzlich auch Methoden besitzen"),". Dies erm\xf6glicht es, einen gut lesbaren und flexibel einsetzbaren Code zu schreiben. Es wird dann auch von objektorientierter Programmierung gesprochen."),(0,r.kt)("p",null,"Stehen bei Variablen ",(0,r.kt)("strong",{parentName:"p"},"vordefinierte Variablentypen")," zur Verf\xfcgung (",(0,r.kt)("inlineCode",{parentName:"p"},"int"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"float"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"char"),", ...), so ist es bei Objekten notwendig, den ",(0,r.kt)("strong",{parentName:"p"},"Objekttyp")," selbst als eine Art Bauplan f\xfcr das Objekt zu programmieren. In der objektorientierten Programmierung wird dieser (selbst geschriebene) Objekttyp ",(0,r.kt)("strong",{parentName:"p"},"Klasse")," genannt."),(0,r.kt)("p",null,"Aber was ist nun der ",(0,r.kt)("strong",{parentName:"p"},"Vorteil von Klassen bzw. Objekten"),". Nehmen wir als Beispiel f\xfcr den Arduino eine Schaltung mit 5 LEDs. Jede LED hat einen eigenen Pin-Anschluss, einen eigenen Zustand (",(0,r.kt)("em",{parentName:"p"},"an/aus"),") und soll mit festgelegten An-/Auszeiten blinken k\xf6nnen. Dieses Verhalten lie\xdfe sich ohne Weiteres auch ohne eine Klasse f\xfcr die LEDs realisieren. Allerdings m\xfcssten daf\xfcr eine Menge globaler Variablen deklariert werden, damit jede  LED unabh\xe4ngig voneinander gesteuert werden kann. Das macht den Code schnell un\xfcbersichtlich und schwer zu lesen:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"bool zustandLED1;\nbool zustandLED2;\n// ...\n\nint anZeit1;\nint anZeit2;\n//  ...\n\nint ausZeit1;\nint ausZeit2;\n// ... \n")),(0,r.kt)("p",null,"Der Vorteil der objektorientierten Programmierung liegt aber darin, das wir nur ",(0,r.kt)("strong",{parentName:"p"},"eine")," Klasse f\xfcr beiliebig viele LEDs schreiben m\xfcssen. Ist die Klasse programmiert, k\xf6nnen beliebig viele Objekte f\xfcr die realen LEDs erzeugt werden. Der Code bleibt \xfcbersichtlich und leicht verst\xe4ndlich."),(0,r.kt)("h2",{id:"beispiel-einer-led-klasse"},"Beispiel einer LED-Klasse"),(0,r.kt)("p",null,"Am Beispiel einer einfachen LED-Klasse, welche eine LED umschalten (togglen) soll, wird im Folgenden das Grundkonzept der objektorientierten Programmierung erl\xe4utert. "),(0,r.kt)("img",{src:"/img/arduino/ObjektKlassse.png",alt:"Klasse und Objekt",width:"400px",className:"center"}),(0,r.kt)("h3",{id:"klassendefinition"},"Klassendefinition"),(0,r.kt)("p",null,"Um eine Klasse zu schreiben (oder besser zu definieren) wird das Schl\xfcsselwort ",(0,r.kt)("inlineCode",{parentName:"p"},"class")," verwendet.  Zwischen die geschweiften Klammern ",(0,r.kt)("inlineCode",{parentName:"p"},"{ ... }")," folgt der Code f\xfcr die Klasse. Nach der Klassenbeschreibung folgt ein Semikolon."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"class Led {\n  // Beschreibung der Klasse\n\n}; // Semikolon am Ende\n")),(0,r.kt)("p",null,"Die LED soll sp\xe4ter mit einem einfachen Befehl (",(0,r.kt)("inlineCode",{parentName:"p"},"toggle()"),") ihren Zustand umschalten k\xf6nnen (an/aus). Daf\xfcr muss die Klasse Attribute  (Variablen) zum Speichern des aktuellen LED-Zustands (",(0,r.kt)("inlineCode",{parentName:"p"},"stateLed"),") und des verwendeten LED-Pins (",(0,r.kt)("inlineCode",{parentName:"p"},"pinLed"),") haben."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"class Led {\n    // Attribute (Variablen) der Klasse\n    int  pinLed;          // LED-Pin\n    bool stateLed;        // Zustand der LED \n};\n")),(0,r.kt)("h3",{id:"konstruktor"},"Konstruktor"),(0,r.kt)("p",null,"Da eine Klasse nur eine Art Bauplan f\xfcr die sp\xe4teren Objekte ist, muss es auch eine M\xf6glichkeit geben, dem Objekt beim Erzeugen ein paar Informationen zu \xfcbergeben. Hierf\xfcr wird der ",(0,r.kt)("strong",{parentName:"p"},"Konstruktor")," verwendet."),(0,r.kt)("p",null,"Der Konstruktor ist eine spezielle Methode, welche einmalig beim Erzeugen eines Objektes aufgerufen wird. Der Konstruktor hat, wie alle anderen Methoden einer Klasse auch, Zugriff auf die Attribute (Variablen) einer Klasse. Der Konstruktor wird genauso wie eine normale Methode definiert, jedoch ohne das Schl\xfcsselwort ",(0,r.kt)("inlineCode",{parentName:"p"},"void"),". ",(0,r.kt)("strong",{parentName:"p"},"Der Name des Konstruktors entspricht dem Klassennamen"),"."),(0,r.kt)("p",null,"Damit auf den Konstruktor auch zugegriffen werden kann, muss das der Klasse durch das Schl\xfcsselwort ",(0,r.kt)("inlineCode",{parentName:"p"},"public")," mitgeteilt werden. Auf alle Methoden und Attribute, die nach ",(0,r.kt)("inlineCode",{parentName:"p"},"public:")," folgen, kann sp\xe4ter direkt zugegriffen werden."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"class Led {                    // Beginn der Klassendefinition\n                               // Attribute (Eigenschaften) der Klasse\n    int  pinLed;               // LED-Pin\n    bool stateLed;             // Zustand der LED \n  //highlight-next-line  \n  public:                      // alle Methoden (oder Attribute) nach public sind \xf6ffentlich\n\n    //highlight-start\n    Led(int pPin) {            // Konstruktor (ohne void, int, etc.)\n      pinLed   = pPin;         // Attribut `pinLed` erh\xe4lt den Wert des Konstruktor-Parameters `pPin` \n      stateLed = false;        // Zustand der LED auf false (LOW)\n      pinMode(pinLed, OUTPUT); // pinLed als Ausgang definieren\n    }\n   //highlight-end \n};   \n")),(0,r.kt)("p",null,"Der Konstruktor im obigen Beispiel erwartet als Parameter (",(0,r.kt)("inlineCode",{parentName:"p"},"pPin"),") den verwendeten Pin. Innerhalb des Konstruktors wird dem Attribut ",(0,r.kt)("inlineCode",{parentName:"p"},"pinLed")," dann der Wert des Parameters \xfcbergeben. Das Objekt speichert also den f\xfcr die LED verwendeten Pin als Attribut. Au\xdferdem wird der Zustand der LED in ",(0,r.kt)("inlineCode",{parentName:"p"},"stateLed")," auf ",(0,r.kt)("inlineCode",{parentName:"p"},"false")," gesetzt. Die LED soll also aus sein. Als letztes wird der angegeben Pin als Ausgang definiert."),(0,r.kt)("h3",{id:"methode-zum-umschalten"},"Methode zum Umschalten"),(0,r.kt)("p",null,"Was der LED-Klasse an dieser Stelle noch fehlt, ist die Methode ",(0,r.kt)("inlineCode",{parentName:"p"},"toggle()")," zum Umschalten der LED. Da auf die Methode, genauso wie den Konstruktor, \xf6ffentlich zugegriffen werden soll, wird sie nach dem Schl\xfcsselwort ",(0,r.kt)("inlineCode",{parentName:"p"},"public")," definiert."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"// Methode der Led-Klasse\nvoid toggle() {          // Die Methoden einer Klassen k\xf6nnen auf die Attribute zugreifen      \n  stateLed = !stateLed; \n  digitalWrite(pin, stateLed);\n} \n")),(0,r.kt)("p",null,"Mit der Zeile"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"stateLed = !stateLed; \n")),(0,r.kt)("p",null,"wird der logische Wert des Attributs ",(0,r.kt)("inlineCode",{parentName:"p"},"stateLed")," negiert. War ",(0,r.kt)("inlineCode",{parentName:"p"},"stateLed")," zuerst ",(0,r.kt)("inlineCode",{parentName:"p"},"true"),", ist es danach ",(0,r.kt)("inlineCode",{parentName:"p"},"false"),". Wird anschlie\xdfend der Zustand der LED mit dem Befehl "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"digitalWrite(pin, stateLed);\n")),(0,r.kt)("p",null,"aktualisiert, so \xe4ndert die LED bei jedem Aufruf der Methode ihren Zustand."),(0,r.kt)("h3",{id:"das-vollst\xe4ndige-programm"},"Das vollst\xe4ndige Programm"),(0,r.kt)("p",null,"Im vollst\xe4ndigen Programm sollen mit der obigen Klasse zwei LED Objekte ",(0,r.kt)("inlineCode",{parentName:"p"},"ledGreen")," und ",(0,r.kt)("inlineCode",{parentName:"p"},"ledRed")," erzeugt werden. Das Erzeugen eines neuen Objektes wird auch ",(0,r.kt)("strong",{parentName:"p"},"instanziieren")," genannt, was nichts anderes bedeutet, als dass mit der Klasse eine neue ",(0,r.kt)("strong",{parentName:"p"},"Instanz")," erzeugt wird."),(0,r.kt)("p",null,"Mit dem Klassennamen (",(0,r.kt)("inlineCode",{parentName:"p"},"Led"),") gefolgt von einem frei w\xe4hlbaren Namen f\xfcr das Objekt (z.B. ",(0,r.kt)("inlineCode",{parentName:"p"},"ledGreen"),") und dem Parameter f\xfcr den Konstruktor k\xf6nnen nun verschiedene Objekte erzeugt werden."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Led ledGreen(4);  // ein `Led` Objekt f\xfcr Pin 4\nLed ledRed(5);    // ein weiteres `Led` Objekt f\xfcr Pin 5\n")),(0,r.kt)("p",null,"Zu guter Letzt muss die Method ",(0,r.kt)("inlineCode",{parentName:"p"},"toggle()")," f\xfcr das jeweilige Objekt noch aufgerufen werden. Daf\xfcr wird das Objekt mit einem Punkt ",(0,r.kt)("inlineCode",{parentName:"p"},".")," mit dem Methodennamen verkn\xfcpft."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"ledGreen.toggle();    // Methodenaufruf vom Objekt `ledGreen`\nledRed.toggle();      // Methodenaufruf vom Objekt `ledRed`\n\n")),(0,r.kt)("p",null,"Zusammengefasst ergibt sich folgendes Programm f\xfcr zwei umschaltbare LEDs mit einer Led-Klasse."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-arduino",metastring:'title="umschaltenObjekte.ino"',title:'"umschaltenObjekte.ino"'},"class Led {               // Beginn der Klassendefinition\n    int  pinLed;          // LED-Pin (Attritbute der Klasse)\n    bool stateLed;        // Zustand der LED \n\n  public:                 // alle Methoden (oder Attribute) nach public sind \xf6ffentlich\n    Led(int pPin) {       // Konstruktor (ohne void, int, etc.)\n      pinLed   = pPin;\n      stateLed = false;\n      pinMode(pinLed, OUTPUT);\n    }\n    void toggle() {       // Die Methoden einer Klassen k\xf6nnen auf die Attribute zugreifen      \n      stateLed = !stateLed; \n      digitalWrite(pinLed, stateLed);\n    }\n};                        // Eine Klassendefinition endet mit einem Semikolon\n\nLed ledGreen(4);  // ein `Led` Objekt mit dem Namen `ledGreen` mit Pin 4\nLed ledRed(5);      // ein weiteres `Led` Objekt mit Pin 5\n\nvoid setup() {\n  // bleibt leer\n}\n\nvoid loop() {\n  ledGreen.toggle();      // Methodenaufruf vom Objekt ledGreen\n  delay(200);\n  ledRed.toggle();        // Methodenaufruf vom Objekt ledGreen\n  delay(800);\n  ledGreen.toggle();\n  delay(200);\n  ledRed.toggle();\n  delay(800);\n}\n")),(0,r.kt)("h2",{id:"wie-nutze-ich-tabs-mit-klassen"},"Wie nutze ich Tabs mit Klassen"),(0,r.kt)("p",null,"Das vollst\xe4ndige Programm mit der LED Klasse kann auch in ",(0,r.kt)("strong",{parentName:"p"},"mehrere Tabs unterteilt werden"),". Wird eine Klasse in einem separaten Tab definiert, so muss der Name des Tabs die Dateiendung ",(0,r.kt)("inlineCode",{parentName:"p"},".cpp")," erhalten. Au\xdferdem muss mit dem Befehl ",(0,r.kt)("inlineCode",{parentName:"p"},'#include "LedKlasse.cpp"')," der entsprechende Tab in das Hauptprogram eingebunden werden."),(0,r.kt)("p",null,"Das ",(0,r.kt)("strong",{parentName:"p"},"Hauptprogramm")," (mit ",(0,r.kt)("inlineCode",{parentName:"p"},"void setup()")," und ",(0,r.kt)("inlineCode",{parentName:"p"},"void loop()"),") steht in dem ",(0,r.kt)("strong",{parentName:"p"},"ersten Tab")," mit dem Namen des Sketches (",(0,r.kt)("inlineCode",{parentName:"p"},"Blink"),"). Klassen, welche in einem anderen Tab definiert werden, m\xfcssen mit dem Befehl ",(0,r.kt)("inlineCode",{parentName:"p"},'#include "LedKlasse.cpp"')," in das Hauptprogramm eingebunden werden."),(0,r.kt)("p",null,"Tabs, in denen ",(0,r.kt)("strong",{parentName:"p"},"Klassen")," definiert werden, m\xfcssen mit der Dateiendung ",(0,r.kt)("inlineCode",{parentName:"p"},".cpp")," (z.B. ",(0,r.kt)("inlineCode",{parentName:"p"},"LedKlasse.cpp"),") benannt werden. Damit in diesen Tabs auch die Arduino-Befehle genutzt werden k\xf6nnen, muss die ",(0,r.kt)("strong",{parentName:"p"},"Arduino-Bibliothek")," mit dem Befehl ",(0,r.kt)("inlineCode",{parentName:"p"},"#include <Arduino.h>")," ",(0,r.kt)("strong",{parentName:"p"},"eingebunden werden"),"."),(0,r.kt)("p",null,"Au\xdferdem m\xfcssen die Tabs (eigentlich eigene Dateien) dem Hauptprogramm mit dem ",(0,r.kt)("inlineCode",{parentName:"p"},"#inlcude")," Befehl zug\xe4nglich gemacht werden."),(0,r.kt)(a.Z,{defaultValue:"Blink",values:[{label:"Blink",value:"Blink"},{label:"LedKlasse.cpp",value:"LedKlasse.cpp"}],mdxType:"Tabs"},(0,r.kt)(l.Z,{value:"Blink",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-arduino",metastring:'title="Blink"',title:'"Blink"'},'//highlight-next-line\n#include "LedKlasse.cpp"  // Einbinden der Datei LedKlasse.cpp mit der `Led` Klasse\n\n#define LED_GREEN 3\n#define LED_RED   6\n\nLed ledGreen(LED_GREEN);  // ein `Led` Objekt mit dem Namen `ledGreen` mit Pin 4\nLed ledRed(LED_RED);      // ein weiteres `Led` Objekt mit Pin 5\n\nvoid setup() {\n  // bleibt leer\n}\n\nvoid loop() {\n  ledGreen.toggle();      // Methodenaufruf vom Objekt ledGreen\n  delay(200);\n  ledRed.toggle();        // Methodenaufruf vom Objekt ledGreen\n  delay(800);\n  ledGreen.toggle();\n  delay(200);\n  ledRed.toggle();\n  delay(800);\n}\n'))),(0,r.kt)(l.Z,{value:"LedKlasse.cpp",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-arduino",metastring:'title="LedKlasse.cpp"',title:'"LedKlasse.cpp"'},"//highlight-next-line\n#include <Arduino.h>      // Einbinden der Datei Arduino-Bibliothek\n\nclass Led {               // Beginn der Klassendefinition\n    int  pinLed;          // LED-Pin (Attritbute der Klasse)\n    bool stateLed;        // Zustand der LED \n\n  public:                 // alle Methoden (oder Attribute) nach public sind \xf6ffentlich\n    Led(int pPin) {       // Konstruktor (ohne void, int, etc.)\n      pinLed   = pPin;\n      stateLed = false;\n      pinMode(pinLed, OUTPUT);\n    }\n    void toggle() {       // Die Methoden einer Klassen k\xf6nnen auf die Attribute zugreifen      \n      stateLed = !stateLed; \n      digitalWrite(pinLed, stateLed);\n    }\n};                        // Eine Klassendefinition endet immer mit einem Semikolon\n")))),(0,r.kt)("details",{className:"ueben"}," ",(0,r.kt)("summary",null,"Aufgaben"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Erweitern Sie die ",(0,r.kt)("inlineCode",{parentName:"p"},"Led")," Klasse im obigen Beispielprogramm um die Methoden ",(0,r.kt)("inlineCode",{parentName:"p"},"anschalten()")," und ",(0,r.kt)("inlineCode",{parentName:"p"},"ausschalten()"),". Testen Sie die neuen Methoden mit einem geeignetem Programm.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Schreiben Sie eine Klasse ",(0,r.kt)("inlineCode",{parentName:"p"},"Blinker"),", welche eine Led blinken l\xe4sst."),(0,r.kt)("p",{parentName:"li"},"Um die LED mit den  vorgegebenen An- und Auszeiten blinken zu lassen, wird eine Methode ",(0,r.kt)("inlineCode",{parentName:"p"},"update()")," ben\xf6tigt, welche regelm\xe4\xdfig aufgerufen werden muss. Die Methode misst die Zeit seit dem letzten Umschalten der LED und \xfcberpr\xfcft, ob die LED wieder umgeschaltet werden muss."),(0,r.kt)("p",{parentName:"li"},"Nutzen Sie die Vorlage und erg\xe4nzen Sie den Code f\xfcr die Methoden und ",(0,r.kt)("inlineCode",{parentName:"p"},"update()")," und ",(0,r.kt)("inlineCode",{parentName:"p"},"setBlink()")," (legt die An-/Auszeit des Blinkers fest)."),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre"},"#define LED1 3 \n#define LED2 5\n\nclass Blinker\n{\n    int onTime;  // in ms\n    int offTime; // in ms\n    int pinLed;\n    int stateLed;\n    unsigned long lastTime;\n\n  public:\n    Blinker(int pin)\n    {\n      onTime = 1000;\n      offTime = 1000;\n      pinLed = pin;\n      lastTime = 0;\n      stateLed = LOW;\n      \n      pinMode(pinLed, OUTPUT);\n    }\n\n    // L\xe4sst die LED durch regelm\xe4\xdfiges Aufrufen blinken.\n    void update() \n    {\n      // ***** Fehlenden Code erg\xe4nzen *****\n    }\n\n    // Konfiguriert die An- und Auszeit des Blinkers\n    void setBlink(int pOn, int pOff)\n    {\n      // ***** Fehlenden Code erg\xe4nzen *****\n    }\n}; \n\nBlinker blink1(LED1);\nBlinker blink2(LED2);\n\nvoid setup() {\n  blink1.setBlink(500, 100);\n  blink2.setBlink(400, 200);\n}\n\nvoid loop() {\n  blink1.update();\n  blink2.update();\n}\n"))))),(0,r.kt)("h2",{id:"ein-array-mit-objekten"},"Ein Array mit Objekten"),(0,r.kt)("p",null,"Grunds\xe4tzlich ist es bei einem ",(0,r.kt)("a",{parentName:"p",href:"/docs/arduino/array"},"Array")," egal, von welchen Datentyp die Elemente sind (solange alle Elemente den selben Datentyp haben). Deshalb kann auch ein Array aus LED-Objekten erzeugt werden."),(0,r.kt)("p",null,"Um ein Array mit Objekten zu erzeugen, wird zuerst der Objekttyp (Klassenname) ",(0,r.kt)("inlineCode",{parentName:"p"},"Led")," und danach der Namen des Arrays ",(0,r.kt)("inlineCode",{parentName:"p"},"ledListe"),"geschrieben. Nach dem Arraynamen folgen zwei eckige Klammern ",(0,r.kt)("inlineCode",{parentName:"p"},"[]"),", welche anzeigen, dass es sich um einen Array handelt. "),(0,r.kt)("p",null,"Anschlie\xdfend werden in einer geschweiften Klammer ",(0,r.kt)("inlineCode",{parentName:"p"},"{ ... }")," die einzelnen Elemente, also die jeweiligen LED-Objekte \xfcbergeben."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Led ledListe[] = {Led(3), Led(6), Led(9), Led(10)}; \n")),(0,r.kt)("p",null,"Soll nun ein einzelnes Objekt des Array angesprochen werden, so wird das mit dem entsprechenden Index in eckigen Klammern getan."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"ledListe[0].toggle();  // Schaltet die 1. LED\nledListe[1].toggle();  // Schaltet die 2. LED\n")),(0,r.kt)("details",{className:"ueben"}," ",(0,r.kt)("summary",null,"Aufgaben"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Erweitern Sie die Schaltung der ",(0,r.kt)("a",{parentName:"li",href:"/docs/arduino/objectOriented#aufgaben-klassen"},"Aufgabe 2")," auf insgesamt 5 LEDs. \xdcberlegen Sie sich ein interessantes Blinkmuster, welches Sie mit der Led-Klasse und einem ",(0,r.kt)("strong",{parentName:"li"},"Array aus Led-Objekten")," programmieren."))),(0,r.kt)("h2",{id:"links"},"Links"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://paulmurraycbr.github.io/ArduinoTheOOWay.html"},"Arduino the Object Oriented Way")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://learn.adafruit.com/multi-tasking-the-arduino-part-1/a-classy-solution"},"A Classy Solution - Adafruit")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://www.youtube.com/watch?v=S_uaROFnWSg"},"Tutorial: Object Oriented Programming with the Arduino"))))}k.isMDXComponent=!0}}]);