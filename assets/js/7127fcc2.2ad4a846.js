"use strict";(self.webpackChunkspace_hal=self.webpackChunkspace_hal||[]).push([[4722],{3905:(e,n,t)=>{t.d(n,{Zo:()=>o,kt:()=>p});var i=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);n&&(i=i.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,i)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?a(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,i,r=function(e,n){if(null==e)return{};var t,i,r={},a=Object.keys(e);for(i=0;i<a.length;i++)t=a[i],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(i=0;i<a.length;i++)t=a[i],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var d=i.createContext({}),u=function(e){var n=i.useContext(d),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},o=function(e){var n=u(e.components);return i.createElement(d.Provider,{value:n},e.children)},m="mdxType",c={inlineCode:"code",wrapper:function(e){var n=e.children;return i.createElement(i.Fragment,{},n)}},g=i.forwardRef((function(e,n){var t=e.components,r=e.mdxType,a=e.originalType,d=e.parentName,o=s(e,["components","mdxType","originalType","parentName"]),m=u(t),g=r,p=m["".concat(d,".").concat(g)]||m[g]||c[g]||a;return t?i.createElement(p,l(l({ref:n},o),{},{components:t})):i.createElement(p,l({ref:n},o))}));function p(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var a=t.length,l=new Array(a);l[0]=g;var s={};for(var d in n)hasOwnProperty.call(n,d)&&(s[d]=n[d]);s.originalType=e,s[m]="string"==typeof e?e:r,l[1]=s;for(var u=2;u<a;u++)l[u]=t[u];return i.createElement.apply(null,l)}return i.createElement.apply(null,t)}g.displayName="MDXCreateElement"},4036:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>l,default:()=>c,frontMatter:()=>a,metadata:()=>s,toc:()=>u});var i=t(7462),r=(t(7294),t(3905));const a={title:"Steuern zeitkritischer Aufgaben oder Multitasking",sidebar_label:"Zeitkritische Aufgaben",custom_edit_url:null,keywords:["Zeitsteuerung","Arduino","millis-Funktion","nichtblockierende Funktionen","blockierende Funktionen","Blinken","LED","Lauflicht","Reaktionstester","Multitasking","led blinken ohne delay"]},l=void 0,s={unversionedId:"arduino/millis",id:"arduino/millis",title:"Steuern zeitkritischer Aufgaben oder Multitasking",description:"Bisher wurde nur die delay() Funktion, welche den Programmablauf f\xfcr die angegebene Zeit unterbricht, zum Steuern zeitkritischer Aufgaben verwendet. Hierbei handelt es sich um eine blockierende Funktion, da der Mikrocontroller w\xe4hrend der Programmverz\xf6gerung keine anderen Aufgaben ausf\xfchren kann.",source:"@site/docs/arduino/millis.md",sourceDirName:"arduino",slug:"/arduino/millis",permalink:"/docs/arduino/millis",draft:!1,editUrl:null,tags:[],version:"current",frontMatter:{title:"Steuern zeitkritischer Aufgaben oder Multitasking",sidebar_label:"Zeitkritische Aufgaben",custom_edit_url:null,keywords:["Zeitsteuerung","Arduino","millis-Funktion","nichtblockierende Funktionen","blockierende Funktionen","Blinken","LED","Lauflicht","Reaktionstester","Multitasking","led blinken ohne delay"]},sidebar:"mySidebar",previous:{title:"Funktionen",permalink:"/docs/arduino/functions"},next:{title:"Taster entprellen",permalink:"/docs/arduino/debounce"}},d={},u=[{value:"<code>millis()</code>",id:"millis",level:2},{value:"Blinken mit <code>millis()</code>",id:"blinken-mit-millis",level:2},{value:"Erl\xe4uterungen zum Programm",id:"erl\xe4uterungen-zum-programm",level:3}],o={toc:u},m="wrapper";function c(e){let{components:n,...t}=e;return(0,r.kt)(m,(0,i.Z)({},o,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Bisher wurde nur die ",(0,r.kt)("a",{parentName:"p",href:"/docs/arduino/helloworld/#delay"},(0,r.kt)("inlineCode",{parentName:"a"},"delay()"))," Funktion, welche den Programmablauf f\xfcr die angegebene Zeit unterbricht, zum Steuern zeitkritischer Aufgaben verwendet. Hierbei handelt es sich um eine ",(0,r.kt)("strong",{parentName:"p"},"blockierende Funktion"),", da der Mikrocontroller w\xe4hrend der Programmverz\xf6gerung keine anderen Aufgaben ausf\xfchren kann."),(0,r.kt)("h2",{id:"millis"},(0,r.kt)("inlineCode",{parentName:"h2"},"millis()")),(0,r.kt)("p",null,"Eine bessere M\xf6glichkeit zur Steuerung von zeitlichen Abl\xe4ufen ergibt sich mit der ",(0,r.kt)("inlineCode",{parentName:"p"},"millis()")," Methode, welche die (vergangene) Zeit seit dem Programmstart angibt."),(0,r.kt)("p",null,"Durch den Aufruf der folgenden Zeilen ist es m\xf6glich, die seit dem Start des Arduinos vergangene Zeit in Millisekunden zu bestimmen. "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-arduino"},"long aktuelleZeit;       // Variable vom Typ long (32 bit)\naktuelleZeit = millis(); // seit dem Start vergangene Zeit in Millisekunden (ms)\n")),(0,r.kt)("p",null,"Da die R\xfcckgabewerte der ",(0,r.kt)("inlineCode",{parentName:"p"},"millis()"),"-Funktion relativ schnell sehr gro\xdf werden k\xf6nnen, sollten diese  immer einer Variablen vom Typ  ",(0,r.kt)("inlineCode",{parentName:"p"},"long")," oder besser vom Typ ",(0,r.kt)("inlineCode",{parentName:"p"},"unsinged long")," \xfcbergeben werden."),(0,r.kt)("h2",{id:"blinken-mit-millis"},"Blinken mit ",(0,r.kt)("inlineCode",{parentName:"h2"},"millis()")),(0,r.kt)("p",null," Im folgenden Programm wird nicht einfach nur bis zum Umschalten der LED mit der ",(0,r.kt)("inlineCode",{parentName:"p"},"delay()")," Methode gewartet, sondern in einer Schleife ",(0,r.kt)("em",{parentName:"p"},"regelm\xe4\xdfig auf die Uhr geschaut"),"  und \xfcberpr\xfcft, ob die LED umgeschaltet werden muss. Da nicht nur gewartet wird, sondern ",(0,r.kt)("strong",{parentName:"p"},"das vergangene Zeitintervall immer wieder \xfcberpr\xfcft")," wird, k\xf6nnen zwischen jedem neuen \xdcberpr\xfcfen der Zeit auch andere Aktionen ausgef\xfchrt werden."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-arduino"},"// L\xe4sst eine LED mit Hilfe der millis() Funktion blinken. \n\n#define LED 2                             // Pin der LED\n\nint zustandLED = LOW;                     // zu setzender LED-Zustand\nunsigned long zeitLetztesUmschalten = 0;  // Zeitpunkt LED-\xc4nderung\nunsigned long blinkZeit = 1000;           // Blinkintervall in ms\n\nvoid setup() \n{\n  pinMode(LED, OUTPUT);                   // Pin als Output\n}\n\nvoid loop() \n{\n  //highlight-next-line         \n  unsigned long aktuelleZeit = millis(); // Zeit seit Programmstart in ms\n\n  // Es wird die Zeit bestimmt, die seit dem letzten Umschalten der LED vergangen\n  // ist. Ist die vergangene Zeit gr\xf6\xdfer gleich `blinkZeit`, so wird der Wert\n  // von `zustandLED` angepasst und anschlie\xdfend der Pin auf den entsprechenden\n  // Zustand gesetzt.\n  //highlight-next-line         \n  if (aktuelleZeit - zeitLetztesUmschalten >= blinkZeit) \n  {\n    if (zustandLED == LOW){ // \xdcberpr\xfcfen des LED Zustands\n      zustandLED = HIGH;\n    } \n    else{\n      zustandLED = LOW;\n    }\n    digitalWrite(LED, zustandLED);         // Pin auf `zustandLED` setzen\n    //highlight-next-line           \n    zeitLetztesUmschalten = aktuelleZeit;  // Zeit des Umschaltens speichern\n  }\n}\n")),(0,r.kt)("h3",{id:"erl\xe4uterungen-zum-programm"},"Erl\xe4uterungen zum Programm"),(0,r.kt)("p",null,"Mit der Zeile"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"unsigned long aktuelleZeit = millis(); // Zeit seit Programmstart in Millisekunden\n")),(0,r.kt)("p",null,"wird der Variablen ",(0,r.kt)("inlineCode",{parentName:"p"},"aktuelleZeit")," die seit dem Programmstart vergangene Zeit in Millisekunden zugewiesen. "),(0,r.kt)("p",null,"Da die LED ihren Zustand immer dann \xe4ndern soll, wenn die gegebene Zeitdifferenz ",(0,r.kt)("inlineCode",{parentName:"p"},"blinkZeit")," vergangen ist, wird in der ",(0,r.kt)("inlineCode",{parentName:"p"},"if"),"-Verzweigung die seit dem letzten Umschalten  vergangene Zeit bestimmt: ",(0,r.kt)("inlineCode",{parentName:"p"},"aktuelleZeit - zeitLetztesUmschalten"),". "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-arduino"},"if (aktuelleZeit - zeitLetztesUmschalten >= blinkZeit) \n")),(0,r.kt)("p",null,"Ist seit dem  letzten Umschalten mehr Zeit als in ",(0,r.kt)("inlineCode",{parentName:"p"},"blinkZeit")," angegeben vergangen, so wird als erstes der Zustand der LED \xfcberpr\xfcft:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-arduino"},"if (zustandLED == LOW){ // \xdcberpr\xfcfen des LED Zustands\n  zustandLED = HIGH;\n} \nelse{\n  zustandLED = LOW;\n}\n")),(0,r.kt)("p",null," Hierf\xfcr wurde global die Zustandsvariable ",(0,r.kt)("inlineCode",{parentName:"p"},"zustandLED")," definiert. Soll der Zustand der LED ge\xe4ndert werden (an oder aus), so wird der neue Zustand der LED in der Variable ",(0,r.kt)("inlineCode",{parentName:"p"},"zustandLED")," vermerkt ",(0,r.kt)("strong",{parentName:"p"},"und anschlie\xdfend")," mit"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-arduino"},"digitalWrite(LED, zustandLED);    // Pin auf `zustandLED` setzen\n")),(0,r.kt)("p",null,"der LED \xfcbergeben. Erst durch den Befehl ",(0,r.kt)("inlineCode",{parentName:"p"},"digitalWrite()")," wird die LED umgeschaltet."),(0,r.kt)("p",null,"Anschlie\xdfend muss der Zeitpunkt des Umschaltens gespeichert werden, damit sp\xe4ter wieder die Zeit zum erneuten Umschalten bestimmt werden kann:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-arduino"},"zeitLetztesUmschalten = aktuelleZeit;     // Zeit des Umschaltens speichern\n")),(0,r.kt)("p",null,"Mit der ",(0,r.kt)("inlineCode",{parentName:"p"},"millis()"),"-Funktion kann auch ein ",(0,r.kt)("strong",{parentName:"p"},"einfaches Multitasking")," (also das scheinbar parallele Abarbeiten von unterschiedlichen Aufgaben) auf dem Arduino realisiert werden."),(0,r.kt)("details",{className:"ueben"}," ",(0,r.kt)("summary",null,"Aufgaben"),(0,r.kt)("p",null,"Verwenden Sie zum L\xf6sen der Aufgaben ",(0,r.kt)("strong",{parentName:"p"},"nicht")," die ",(0,r.kt)("inlineCode",{parentName:"p"},"delay()")," Funktion."),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Schreiben Sie ein Programm, welches eine LED mit ",(0,r.kt)("strong",{parentName:"li"},"verschiedene An- und Auszeiten blinken")," la\u0308sst. Nutzen Sie ",(0,r.kt)("inlineCode",{parentName:"li"},"millis()"),"."),(0,r.kt)("li",{parentName:"ol"},"Schlie\xdfen Sie eine zweite LED an den Arduino an und lassen sie diese ",(0,r.kt)("strong",{parentName:"li"},"unabh\xe4ngig")," von der ersten LED mit einem ",(0,r.kt)("strong",{parentName:"li"},"anderen Rhythmus")," blinken."),(0,r.kt)("li",{parentName:"ol"},"Schreiben Sie ein Programm, welches eine LED nur dann ",(0,r.kt)("strong",{parentName:"li"},"langsam blinken")," la\u0308sst,",(0,r.kt)("strong",{parentName:"li"}," wenn ein Taster gedr\xfcckt")," ist. Sobald der Taster losgelassen wurde, soll die LED aus gehen (nicht erst nach dem Beenden des Blink-Intervalls)."),(0,r.kt)("li",{parentName:"ol"},"Bei vielen Anwendungen soll das Hauptprogramm erst nach dem Bet\xe4tigen eines Tasters gestartet werden. Schreiben sie Programm, welches die ",(0,r.kt)("inlineCode",{parentName:"li"},"setup()")," Funktion erst nach dem Dr\xfccken eines Tasters beendet. Als Zeichen, dass auf eine Tastereingabe gewartet wird, soll zur selben Zeit eine LED blinken. Nachdem der Taster gedr\xfcckt wurde, erlicht die LED und auf dem seriellen Monitor wird der Text ",(0,r.kt)("inlineCode",{parentName:"li"},"Programm startet ..."),"  ausgegeben. ",(0,r.kt)("em",{parentName:"li"},"Hinweis: Verwenden Sie eine ",(0,r.kt)("inlineCode",{parentName:"em"},"while"),"-Schleife.")),(0,r.kt)("li",{parentName:"ol"},"Schreiben Sie ein Programm, welches die Zeit misst, die ein Taster gedr\xfcckt ist. Das Ergebnis soll auf dem seriellen Monitor ausgegeben werden:",(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-text"},"Zeit, die der Taster gedr\xfcckt war: x.xx Sekunden\n")),"Beim schnellen Dr\xfccken des Tasters werden die Messergebnisse vermutlich nicht Ihren Erwartungen entsprechen. Analysieren Sie das unerwartete Verhalten."))))}c.isMDXComponent=!0}}]);