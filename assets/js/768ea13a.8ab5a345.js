"use strict";(self.webpackChunkspacehale=self.webpackChunkspacehale||[]).push([[6921],{3905:(e,n,r)=>{r.d(n,{Zo:()=>m,kt:()=>p});var t=r(7294);function a(e,n,r){return n in e?Object.defineProperty(e,n,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[n]=r,e}function i(e,n){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),r.push.apply(r,t)}return r}function s(e){for(var n=1;n<arguments.length;n++){var r=null!=arguments[n]?arguments[n]:{};n%2?i(Object(r),!0).forEach((function(n){a(e,n,r[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):i(Object(r)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(r,n))}))}return e}function d(e,n){if(null==e)return{};var r,t,a=function(e,n){if(null==e)return{};var r,t,a={},i=Object.keys(e);for(t=0;t<i.length;t++)r=i[t],n.indexOf(r)>=0||(a[r]=e[r]);return a}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(t=0;t<i.length;t++)r=i[t],n.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(a[r]=e[r])}return a}var o=t.createContext({}),l=function(e){var n=t.useContext(o),r=n;return e&&(r="function"==typeof e?e(n):s(s({},n),e)),r},m=function(e){var n=l(e.components);return t.createElement(o.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return t.createElement(t.Fragment,{},n)}},c=t.forwardRef((function(e,n){var r=e.components,a=e.mdxType,i=e.originalType,o=e.parentName,m=d(e,["components","mdxType","originalType","parentName"]),c=l(r),p=a,g=c["".concat(o,".").concat(p)]||c[p]||u[p]||i;return r?t.createElement(g,s(s({ref:n},m),{},{components:r})):t.createElement(g,s({ref:n},m))}));function p(e,n){var r=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var i=r.length,s=new Array(i);s[0]=c;var d={};for(var o in n)hasOwnProperty.call(n,o)&&(d[o]=n[o]);d.originalType=e,d.mdxType="string"==typeof e?e:a,s[1]=d;for(var l=2;l<i;l++)s[l]=r[l];return t.createElement.apply(null,s)}return t.createElement.apply(null,r)}c.displayName="MDXCreateElement"},9243:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>o,contentTitle:()=>s,default:()=>u,frontMatter:()=>i,metadata:()=>d,toc:()=>l});var t=r(7462),a=(r(7294),r(3905));const i={id:"wheelEncoder",title:"Bestimung des Fahrtwegs mit dem Motorencoder",sidebar_label:"Motorencoder",description:"Mit Hilfe der Rad-Encoder wird der Roboter geradeaus fahren und seine Geschwindigkeit regeln. Zum Regeln der Geschwindikeit wird ein Integral-Regler verwendet.",custom_edit_url:null,keywords:["Arduino","Roboter","Robotik","Odometrie","Quadraturencoder","Inkrementalgeber","Positionsbestimmung","Radencoder","Motorencoder","geradeaus fahren","Zumo 32u4"]},s=void 0,d={unversionedId:"robotik/wheelEncoder",id:"robotik/wheelEncoder",title:"Bestimung des Fahrtwegs mit dem Motorencoder",description:"Mit Hilfe der Rad-Encoder wird der Roboter geradeaus fahren und seine Geschwindigkeit regeln. Zum Regeln der Geschwindikeit wird ein Integral-Regler verwendet.",source:"@site/docs/robotik/wheelEncoder.mdx",sourceDirName:"robotik",slug:"/robotik/wheelEncoder",permalink:"/docs/robotik/wheelEncoder",draft:!1,editUrl:null,tags:[],version:"current",frontMatter:{id:"wheelEncoder",title:"Bestimung des Fahrtwegs mit dem Motorencoder",sidebar_label:"Motorencoder",description:"Mit Hilfe der Rad-Encoder wird der Roboter geradeaus fahren und seine Geschwindigkeit regeln. Zum Regeln der Geschwindikeit wird ein Integral-Regler verwendet.",custom_edit_url:null,keywords:["Arduino","Roboter","Robotik","Odometrie","Quadraturencoder","Inkrementalgeber","Positionsbestimmung","Radencoder","Motorencoder","geradeaus fahren","Zumo 32u4"]},sidebar:"mySidebar",previous:{title:"Motorencoder",permalink:"/docs/category/motorencoder"},next:{title:"Ge\xadra\xadde\xadaus\xadfahrt",permalink:"/docs/robotik/goStraight"}},o={},l=[{value:"Inkrementalgeber (<em>Incremental Encoder</em>)",id:"inkrementalgeber-incremental-encoder",level:2},{value:"Quadratur-Encoder (<em>Quadrature Encoder</em>)",id:"quadratur-encoder-quadrature-encoder",level:3},{value:"Drehrichtung im Uhrzeigersinn",id:"drehrichtung-im-uhrzeigersinn",level:4},{value:"Drehrichtung entgegen dem Uhrzeigersinn",id:"drehrichtung-entgegen-dem-uhrzeigersinn",level:4},{value:"Auslesen der Rad-Encoder beim Zumo 32u4",id:"auslesen-der-rad-encoder-beim-zumo-32u4",level:2},{value:"Links",id:"links",level:2}],m={toc:l};function u(e){let{components:n,...r}=e;return(0,a.kt)("wrapper",(0,t.Z)({},m,r,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h2",{id:"inkrementalgeber-incremental-encoder"},"Inkrementalgeber (",(0,a.kt)("em",{parentName:"h2"},"Incremental Encoder"),")"),(0,a.kt)("p",null,"Eine der ersten Aufgaben f\xfcr den ",(0,a.kt)("a",{parentName:"p",href:"/docs/robotik/beginning"},"selbstgebauten Roboter")," war es, den Roboter eine Strecke von 1,5 Meter fahren zu lassen. Die L\xf6sung konnte nur durch Probieren von unterschiedliche langen Fahrzeit ermittelt werden. Was dem selbstgebauten Roboter fehlte, war die M\xf6glichkeit den zur\xfcckgelegten Fahrtweg zu messen."),(0,a.kt)("p",null,"Sind die Motoren (oder R\xe4der) mit einem ",(0,a.kt)("a",{parentName:"p",href:"https://de.wikipedia.org/wiki/Inkrementalgeber"},"Inkrementalgeber")," (Radencoder) ausgestattet, kann mit diesen bestimmt werden, wie weit sich die einzelnen Motoren zwischen zwei Messungen gedreht haben. Dadurch wird es m\xf6glich sowohl die ",(0,a.kt)("a",{parentName:"p",href:"/docs/robotik/speedControl"},"Geschwindigkeit")," auch als die gefahrene Strecke oder auch die aktuelle ",(0,a.kt)("a",{parentName:"p",href:"/docs/robotik/odometrie"},"Position")," des Roboters zu bestimmen"),(0,a.kt)("p",null,"Der Zumo 32u4 hat an jedem Motor einen ",(0,a.kt)("a",{parentName:"p",href:"https://www.pololu.com/docs/0J63/3.4"},"Quadratur-Encoder"),", welcher mit einer magnetischen Scheibe pro Motorwelle und zwei ",(0,a.kt)("a",{parentName:"p",href:"https://www.leifiphysik.de/elektrizitaetslehre/bewegte-ladungen-feldern/grundwissen/hall-effekt"},"Hall-Effekt"),"-Sensoren f\xfcr jeden Motor realisiert ist. Der Quadratur-Encoder hat eine Aufl\xf6sung von 12 Schritten pro Umdrehung."),(0,a.kt)("p",null,"Da die R\xe4der nicht direkt, sondern mit einem Getriebe  mit der Motorwelle verbunden sind (\xdcbersetzung 75.81:1), f\xfchrt das zu einer Aufl\xf6sung von ",(0,a.kt)("span",{parentName:"p",className:"math math-inline"},(0,a.kt)("span",{parentName:"span",className:"katex"},(0,a.kt)("span",{parentName:"span",className:"katex-mathml"},(0,a.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,a.kt)("semantics",{parentName:"math"},(0,a.kt)("mrow",{parentName:"semantics"},(0,a.kt)("mn",{parentName:"mrow"},"12"),(0,a.kt)("mo",{parentName:"mrow"},"\xd7"),(0,a.kt)("mn",{parentName:"mrow"},"75.81"),(0,a.kt)("mo",{parentName:"mrow"},"\u2248"),(0,a.kt)("mn",{parentName:"mrow"},"909"),(0,a.kt)("mo",{parentName:"mrow",separator:"true"},","),(0,a.kt)("mn",{parentName:"mrow"},"7")),(0,a.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"12\\times 75.81 \\approx 909,7")))),(0,a.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,a.kt)("span",{parentName:"span",className:"base"},(0,a.kt)("span",{parentName:"span",className:"strut",style:{height:"0.7278em",verticalAlign:"-0.0833em"}}),(0,a.kt)("span",{parentName:"span",className:"mord"},"12"),(0,a.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2222em"}}),(0,a.kt)("span",{parentName:"span",className:"mbin"},"\xd7"),(0,a.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2222em"}})),(0,a.kt)("span",{parentName:"span",className:"base"},(0,a.kt)("span",{parentName:"span",className:"strut",style:{height:"0.6444em"}}),(0,a.kt)("span",{parentName:"span",className:"mord"},"75.81"),(0,a.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2778em"}}),(0,a.kt)("span",{parentName:"span",className:"mrel"},"\u2248"),(0,a.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2778em"}})),(0,a.kt)("span",{parentName:"span",className:"base"},(0,a.kt)("span",{parentName:"span",className:"strut",style:{height:"0.8389em",verticalAlign:"-0.1944em"}}),(0,a.kt)("span",{parentName:"span",className:"mord"},"909"),(0,a.kt)("span",{parentName:"span",className:"mpunct"},","),(0,a.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.1667em"}}),(0,a.kt)("span",{parentName:"span",className:"mord"},"7")))))," Impulsen pro Umdrehung (CPR - counts per revolution)."),(0,a.kt)("img",{src:"/img/robotik/RadEncoder.png",alt:"Ein Radencoder f\xfcr die Odometrie",width:"450px",className:"center"}),(0,a.kt)("h3",{id:"quadratur-encoder-quadrature-encoder"},"Quadratur-Encoder (",(0,a.kt)("em",{parentName:"h3"},"Quadrature Encoder"),")"),(0,a.kt)("p",null,"Der oben dargestellte Rad-Encoder ist ein sehr einfacher Inkrementalgeber. Was diesem Encoder fehlt, ist die M\xf6glichkeit die Drehrichtung des Rades zu bestimmen. Ein Quadratur-Encoder schafft hier Abhilfe. "),(0,a.kt)("p",null,"Bei einem Quadratur-Encoder wird das Rad nicht mit einem Sensor, sondern mit ",(0,a.kt)("strong",{parentName:"p"},"zwei r\xe4umlich versetzten Sensoren")," abgetastet. Dadurch ergibt sich nicht nur eine Impulsfolge, welche angibt, wie weit sich das Rad gedreht hat, sondern ",(0,a.kt)("strong",{parentName:"p"},"zwei Impulsfolgen (A und B)")," aus welchen zus\xe4tzlich auch die Drehrichtung bestimmt werden kann. "),(0,a.kt)("h4",{id:"drehrichtung-im-uhrzeigersinn"},"Drehrichtung im Uhrzeigersinn"),(0,a.kt)("p",null,"In der dargestellten Abbilung sind die beiden Encoder-Sensoren mit den Buchstaben A und B bezeichnet. Der rechte Sensor (A) ist bei einer Drehung im ",(0,a.kt)("strong",{parentName:"p"},"Uhrzeigersinn")," der Sensor, welcher zuerst die Zustands\xe4nderungen (von 0 auf 1 oder andersrum) detektiert. Der Sensor B wird die selbe Zustands\xe4nderung kurz danach detektieren. Das bedeutet, dass direkt nach dem Zustandswechsel des Sensors A, der Sensor B noch im alten Zustand ist. "),(0,a.kt)("p",null,"Bei einer ",(0,a.kt)("strong",{parentName:"p"},"Drehung im Uhrzeigersinn")," gilt bei der Zustands\xe4nderung des Sensors B: ",(0,a.kt)("inlineCode",{parentName:"p"},"B=!A"),"."),(0,a.kt)("img",{src:"/img/robotik/QuadEncoderClockwise.png",alt:"Quadratur Encoder",width:"620",className:"center"}),(0,a.kt)("h4",{id:"drehrichtung-entgegen-dem-uhrzeigersinn"},"Drehrichtung entgegen dem Uhrzeigersinn"),(0,a.kt)("p",null,"Dreht sich das Rad entgegen dem Uhrzeigersinn ist der Sensor B der f\xfchrende Sensor und erkennt die Zustands\xe4nderung als erstes. Aus Sicht des Sensors A bedeutet das, dass der Sensor A bei einer Zustands\xe4nderung den bereits detektierten Zustand vom Sensor B annimmt."),(0,a.kt)("p",null,"Bei einer ",(0,a.kt)("strong",{parentName:"p"},"Drehung entgegen dem Uhrzeigersinn")," gilt bei der Zustands\xe4nderung des Sensors B: ",(0,a.kt)("inlineCode",{parentName:"p"},"B=A"),"."),(0,a.kt)("img",{src:"/img/robotik/QuadEncoderCC.png",alt:"Quadratur Encoder",width:"620",className:"center"}),(0,a.kt)("h2",{id:"auslesen-der-rad-encoder-beim-zumo-32u4"},"Auslesen der Rad-Encoder beim Zumo 32u4"),(0,a.kt)("p",null,"In der Zumo32u4-Bibliothek wird die Klasse ",(0,a.kt)("inlineCode",{parentName:"p"},"Zumo32U4Encoders")," bereitgestellt, welche es mit den Methode ",(0,a.kt)("inlineCode",{parentName:"p"},"getCountsLeft()")," und ",(0,a.kt)("inlineCode",{parentName:"p"},"getCountsRight()")," erm\xf6glicht, die vom Encoder gemessenen Impulse auszugeben. "),(0,a.kt)("p",null,"Die Methoden zum Auslesen der Rad-Encoder verwenden im Hintergrund so genannte ",(0,a.kt)("a",{parentName:"p",href:"https://de.wikipedia.org/wiki/Interrupt"},"Interrupt-Funktionen"),", welches jedesmal, wenn die Encoder einen Impuls erhalten, eine globale Variable im eins erh\xf6hen oder verringern (abh\xe4ngig von der Drehrichtung). Die Methoden ",(0,a.kt)("inlineCode",{parentName:"p"},"getCountsLeft()")," und ",(0,a.kt)("inlineCode",{parentName:"p"},"getCountsRight()")," geben dann die aktuelle Anzahl der aufsummierten Impulse pro Rad an."),(0,a.kt)("p",null,"Die Methoden ",(0,a.kt)("inlineCode",{parentName:"p"},"getCountsAndResetLeft()")," und ",(0,a.kt)("inlineCode",{parentName:"p"},"getCountsAndResetRight()")," verhalten sich wie die anderen beiden Funktionen, setzten jedoch die entsprechende globale Variable f\xfcr die aufsummierten Impulse zur\xfcck."),(0,a.kt)("admonition",{type:"caution"},(0,a.kt)("p",{parentName:"admonition"},"Damit die globalen Z\xe4hler f\xfcr die Encoder-Impulse nicht \xfcberlaufen, sollten regelm\xe4\xdfig die Funktionen ",(0,a.kt)("inlineCode",{parentName:"p"},"getCountsAndResetLeft()")," und ",(0,a.kt)("inlineCode",{parentName:"p"},"getCountsAndResetRight()")," aufgerufen werden.")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-arduino"},"// Anzeigen der Encoder-Werte auf dem Display \n\n#include <Wire.h>\n#include <Zumo32U4.h>\n\nZumo32U4Encoders encoders;                       //  Encoder-Objekt deklarieren\nZumo32U4LCD lcd;\n\nunsigned long lastDisplayTime = 0;\n\nvoid setup() {\n                                                // bleibt leer\n}\n\nvoid loop() {\n  if ((millis() - lastDisplayTime) > 100) {\n\n    int countsLeft = encoders.getCountsLeft();   // Auslesen des globalen Impuls-Z\xe4hlers\n    int countsRight = encoders.getCountsRight(); // Die Impulse werden im Hintergrund gez\xe4hlt\n\n    lcd.clear();\n    lcd.print(countsLeft);\n    lcd.gotoXY(0, 1);\n    lcd.print(countsRight);\n    \n    lastDisplayTime = millis();\n  }\n}\n")),(0,a.kt)("details",{className:"ueben"}," ",(0,a.kt)("summary",null,"Aufgaben"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Die Radencoder haben eine Aufl\xf6sung von 909,7 Impulsen pro Rad-Umdrehung. Bestimmen Sie rechnerisch, wie weit der zur\xfcckgelegte Weg zwischen zwei Encoder-Impulsen ist (Millimeter pro Impuls).\n",(0,a.kt)("em",{parentName:"li"},"Hinweis: Messen Sie den Durchmesser der R\xe4der.")),(0,a.kt)("li",{parentName:"ol"},"Messen Sie die Anzahl der Encoder-Impulse die ben\xf6tigt werden, um eine Strecke von exakt 20 cm zur\xfcckzulegen. Bestimmen Sie hieraus die Encoder-Aufl\xf6sung (in Millimeter pro Impulse)."),(0,a.kt)("li",{parentName:"ol"},"Schreiben Sie ein Programm, welches den Roboter mit Hilfe der Rad-Encoder ",(0,a.kt)("strong",{parentName:"li"},"exakt")," 20 cm weit fahren l\xe4sst. Geben Sie auf dem Display die gefahrene Strecke in Millimetern an. Vergleichen Sie Ihr Ergebnis mit der Aufgabe 2. (Die zur\xfcckgelegt Strecke sollte als Mittelwert aus den beiden Rad-Encodern berechnet werden.)"),(0,a.kt)("li",{parentName:"ol"},"Wiederholen Sie die letzte Aufgabe. Versuchen Sie jedoch den Roboter die 20 cm so schnell wie m\xf6glich zur\xfccklegen zu lassen. Messen Sie die Zeit. (",(0,a.kt)("em",{parentName:"li"},"Hinweis: Nutzen Sie einen geeigneten Regler"),")"))),(0,a.kt)("h2",{id:"links"},"Links"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://lastminuteengineers.com/rotary-encoder-arduino-tutorial/"},"How Rotary Encoder Works and Interface It with Arduino")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://www.pololu.com/docs/0J63/all#3.4"},"Quadratur-Encoder des Zumo 32u4"))))}u.isMDXComponent=!0}}]);