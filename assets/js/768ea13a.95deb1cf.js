"use strict";(self.webpackChunkspace_hal=self.webpackChunkspace_hal||[]).push([[6921],{3905:(e,n,t)=>{t.d(n,{Zo:()=>u,kt:()=>g});var r=t(7294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var o=r.createContext({}),d=function(e){var n=r.useContext(o),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},u=function(e){var n=d(e.components);return r.createElement(o.Provider,{value:n},e.children)},c="mdxType",m={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},p=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,i=e.originalType,o=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),c=d(t),p=a,g=c["".concat(o,".").concat(p)]||c[p]||m[p]||i;return t?r.createElement(g,l(l({ref:n},u),{},{components:t})):r.createElement(g,l({ref:n},u))}));function g(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var i=t.length,l=new Array(i);l[0]=p;var s={};for(var o in n)hasOwnProperty.call(n,o)&&(s[o]=n[o]);s.originalType=e,s[c]="string"==typeof e?e:a,l[1]=s;for(var d=2;d<i;d++)l[d]=t[d];return r.createElement.apply(null,l)}return r.createElement.apply(null,t)}p.displayName="MDXCreateElement"},5162:(e,n,t)=>{t.d(n,{Z:()=>l});var r=t(7294),a=t(6010);const i={tabItem:"tabItem_Ymn6"};function l(e){let{children:n,hidden:t,className:l}=e;return r.createElement("div",{role:"tabpanel",className:(0,a.Z)(i.tabItem,l),hidden:t},n)}},4866:(e,n,t)=>{t.d(n,{Z:()=>v});var r=t(7462),a=t(7294),i=t(6010),l=t(2466),s=t(6550),o=t(1980),d=t(7392),u=t(12);function c(e){return function(e){return a.Children.map(e,(e=>{if(!e||(0,a.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}(e).map((e=>{let{props:{value:n,label:t,attributes:r,default:a}}=e;return{value:n,label:t,attributes:r,default:a}}))}function m(e){const{values:n,children:t}=e;return(0,a.useMemo)((()=>{const e=n??c(t);return function(e){const n=(0,d.l)(e,((e,n)=>e.value===n.value));if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[n,t])}function p(e){let{value:n,tabValues:t}=e;return t.some((e=>e.value===n))}function g(e){let{queryString:n=!1,groupId:t}=e;const r=(0,s.k6)(),i=function(e){let{queryString:n=!1,groupId:t}=e;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!t)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return t??null}({queryString:n,groupId:t});return[(0,o._X)(i),(0,a.useCallback)((e=>{if(!i)return;const n=new URLSearchParams(r.location.search);n.set(i,e),r.replace({...r.location,search:n.toString()})}),[i,r])]}function h(e){const{defaultValue:n,queryString:t=!1,groupId:r}=e,i=m(e),[l,s]=(0,a.useState)((()=>function(e){let{defaultValue:n,tabValues:t}=e;if(0===t.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(n){if(!p({value:n,tabValues:t}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${n}" but none of its children has the corresponding value. Available values are: ${t.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return n}const r=t.find((e=>e.default))??t[0];if(!r)throw new Error("Unexpected error: 0 tabValues");return r.value}({defaultValue:n,tabValues:i}))),[o,d]=g({queryString:t,groupId:r}),[c,h]=function(e){let{groupId:n}=e;const t=function(e){return e?`docusaurus.tab.${e}`:null}(n),[r,i]=(0,u.Nk)(t);return[r,(0,a.useCallback)((e=>{t&&i.set(e)}),[t,i])]}({groupId:r}),k=(()=>{const e=o??c;return p({value:e,tabValues:i})?e:null})();(0,a.useLayoutEffect)((()=>{k&&s(k)}),[k]);return{selectedValue:l,selectValue:(0,a.useCallback)((e=>{if(!p({value:e,tabValues:i}))throw new Error(`Can't select invalid tab value=${e}`);s(e),d(e),h(e)}),[d,h,i]),tabValues:i}}var k=t(2389);const b={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};function f(e){let{className:n,block:t,selectedValue:s,selectValue:o,tabValues:d}=e;const u=[],{blockElementScrollPositionUntilNextRender:c}=(0,l.o5)(),m=e=>{const n=e.currentTarget,t=u.indexOf(n),r=d[t].value;r!==s&&(c(n),o(r))},p=e=>{let n=null;switch(e.key){case"Enter":m(e);break;case"ArrowRight":{const t=u.indexOf(e.currentTarget)+1;n=u[t]??u[0];break}case"ArrowLeft":{const t=u.indexOf(e.currentTarget)-1;n=u[t]??u[u.length-1];break}}n?.focus()};return a.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,i.Z)("tabs",{"tabs--block":t},n)},d.map((e=>{let{value:n,label:t,attributes:l}=e;return a.createElement("li",(0,r.Z)({role:"tab",tabIndex:s===n?0:-1,"aria-selected":s===n,key:n,ref:e=>u.push(e),onKeyDown:p,onClick:m},l,{className:(0,i.Z)("tabs__item",b.tabItem,l?.className,{"tabs__item--active":s===n})}),t??n)})))}function w(e){let{lazy:n,children:t,selectedValue:r}=e;const i=(Array.isArray(t)?t:[t]).filter(Boolean);if(n){const e=i.find((e=>e.props.value===r));return e?(0,a.cloneElement)(e,{className:"margin-top--md"}):null}return a.createElement("div",{className:"margin-top--md"},i.map(((e,n)=>(0,a.cloneElement)(e,{key:n,hidden:e.props.value!==r}))))}function N(e){const n=h(e);return a.createElement("div",{className:(0,i.Z)("tabs-container",b.tabList)},a.createElement(f,(0,r.Z)({},e,n)),a.createElement(w,(0,r.Z)({},e,n)))}function v(e){const n=(0,k.Z)();return a.createElement(N,(0,r.Z)({key:String(n)},e))}},9243:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>u,contentTitle:()=>o,default:()=>g,frontMatter:()=>s,metadata:()=>d,toc:()=>c});var r=t(7462),a=(t(7294),t(3905)),i=t(4866),l=t(5162);const s={id:"wheelEncoder",title:"Bestimung des Fahrtwegs mit dem Motorencoder",sidebar_label:"Motorencoder",description:"Mit Hilfe der Rad-Encoder wird der Roboter geradeaus fahren und seine Geschwindigkeit regeln. Zum Regeln der Geschwindikeit wird ein Integral-Regler verwendet.",custom_edit_url:null,keywords:["Arduino","Roboter","Robotik","Odometrie","Quadraturencoder","Inkrementalgeber","Positionsbestimmung","Radencoder","Motorencoder","geradeaus fahren","Zumo 32u4"]},o=void 0,d={unversionedId:"robotik/wheelEncoder",id:"robotik/wheelEncoder",title:"Bestimung des Fahrtwegs mit dem Motorencoder",description:"Mit Hilfe der Rad-Encoder wird der Roboter geradeaus fahren und seine Geschwindigkeit regeln. Zum Regeln der Geschwindikeit wird ein Integral-Regler verwendet.",source:"@site/docs/robotik/wheelEncoder.mdx",sourceDirName:"robotik",slug:"/robotik/wheelEncoder",permalink:"/docs/robotik/wheelEncoder",draft:!1,editUrl:null,tags:[],version:"current",frontMatter:{id:"wheelEncoder",title:"Bestimung des Fahrtwegs mit dem Motorencoder",sidebar_label:"Motorencoder",description:"Mit Hilfe der Rad-Encoder wird der Roboter geradeaus fahren und seine Geschwindigkeit regeln. Zum Regeln der Geschwindikeit wird ein Integral-Regler verwendet.",custom_edit_url:null,keywords:["Arduino","Roboter","Robotik","Odometrie","Quadraturencoder","Inkrementalgeber","Positionsbestimmung","Radencoder","Motorencoder","geradeaus fahren","Zumo 32u4"]},sidebar:"mySidebar",previous:{title:"Motorencoder",permalink:"/docs/category/motorencoder"},next:{title:"Ge\xadra\xadde\xadaus\xadfahrt",permalink:"/docs/robotik/goStraight"}},u={},c=[{value:"Inkrementalgeber (<em>Incremental Encoder</em>)",id:"inkrementalgeber-incremental-encoder",level:2},{value:"Quadratur-Encoder (<em>Quadrature Encoder</em>)",id:"quadratur-encoder-quadrature-encoder",level:3},{value:"Drehrichtung im Uhrzeigersinn",id:"drehrichtung-im-uhrzeigersinn",level:4},{value:"Drehrichtung entgegen dem Uhrzeigersinn",id:"drehrichtung-entgegen-dem-uhrzeigersinn",level:4},{value:"Auslesen der Rad-Encoder beim 3pi+ 32u4 / Zumo 32u4",id:"auslesen-der-rad-encoder-beim-3pi-32u4--zumo-32u4",level:2},{value:"Beispiel",id:"beispiel",level:3},{value:"Links",id:"links",level:2}],m={toc:c},p="wrapper";function g(e){let{components:n,...t}=e;return(0,a.kt)(p,(0,r.Z)({},m,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h2",{id:"inkrementalgeber-incremental-encoder"},"Inkrementalgeber (",(0,a.kt)("em",{parentName:"h2"},"Incremental Encoder"),")"),(0,a.kt)("p",null,"Eine der ersten Aufgaben f\xfcr den ",(0,a.kt)("a",{parentName:"p",href:"/docs/robotik/beginning"},"selbstgebauten Roboter")," war es, den Roboter eine Strecke von 1,5 Meter fahren zu lassen. Die L\xf6sung konnte nur durch Probieren von unterschiedliche langen Fahrzeit ermittelt werden. Was dem selbstgebauten Roboter fehlte, war die M\xf6glichkeit den zur\xfcckgelegten Fahrtweg zu messen."),(0,a.kt)("p",null,"Sind die Motoren (oder R\xe4der) mit einem ",(0,a.kt)("a",{parentName:"p",href:"https://de.wikipedia.org/wiki/Inkrementalgeber"},"Inkrementalgeber")," (Radencoder) ausgestattet, kann mit diesen bestimmt werden, wie weit sich die einzelnen Motoren zwischen zwei Messungen gedreht haben. Dadurch wird es m\xf6glich sowohl die ",(0,a.kt)("a",{parentName:"p",href:"/docs/robotik/speedControl"},"Geschwindigkeit")," auch als die gefahrene Strecke oder auch die aktuelle ",(0,a.kt)("a",{parentName:"p",href:"/docs/robotik/odometrie"},"Position")," des Roboters zu bestimmen"),(0,a.kt)("p",null,"Der Zumo 32u4 und der 3pi+ 32u4 Roboter haben an jedem Motor einen ",(0,a.kt)("a",{parentName:"p",href:"https://www.pololu.com/docs/0J63/3.4"},"Quadratur-Encoder"),", welcher mit einer magnetischen Scheibe pro Motorwelle und zwei ",(0,a.kt)("a",{parentName:"p",href:"https://www.leifiphysik.de/elektrizitaetslehre/bewegte-ladungen-feldern/grundwissen/hall-effekt"},"Hall-Effekt"),"-Sensoren f\xfcr jeden Motor realisiert ist. Bei beiden Robotern hat der Quadratur-Encoder eine Aufl\xf6sung von 12 Schritten pro Umdrehung."),(0,a.kt)("p",null,"Da die R\xe4der nicht direkt, sondern mit einem Getriebe mit der Motorwelle verbunden sind, muss die Getriebe-\xdcbersetzung bei der Ermittlung der Encoder-Aufl\xf6sung ber\xfccksichtigt werden. "),(0,a.kt)("p",null,"F\xfcr den ",(0,a.kt)("strong",{parentName:"p"},"3pi+ 32u4")," in der Standardausf\xfchrung mit einem 29.86:1 Getriebe ergeben sich  ",(0,a.kt)("span",{parentName:"p",className:"math math-inline"},(0,a.kt)("span",{parentName:"span",className:"katex"},(0,a.kt)("span",{parentName:"span",className:"katex-mathml"},(0,a.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,a.kt)("semantics",{parentName:"math"},(0,a.kt)("mrow",{parentName:"semantics"},(0,a.kt)("mn",{parentName:"mrow"},"12"),(0,a.kt)("mo",{parentName:"mrow"},"\xd7"),(0,a.kt)("mn",{parentName:"mrow"},"29.86"),(0,a.kt)("mo",{parentName:"mrow"},"\u2248"),(0,a.kt)("mn",{parentName:"mrow"},"358.3")),(0,a.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"12\\times 29.86 \\approx 358.3")))),(0,a.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,a.kt)("span",{parentName:"span",className:"base"},(0,a.kt)("span",{parentName:"span",className:"strut",style:{height:"0.7278em",verticalAlign:"-0.0833em"}}),(0,a.kt)("span",{parentName:"span",className:"mord"},"12"),(0,a.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2222em"}}),(0,a.kt)("span",{parentName:"span",className:"mbin"},"\xd7"),(0,a.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2222em"}})),(0,a.kt)("span",{parentName:"span",className:"base"},(0,a.kt)("span",{parentName:"span",className:"strut",style:{height:"0.6444em"}}),(0,a.kt)("span",{parentName:"span",className:"mord"},"29.86"),(0,a.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2778em"}}),(0,a.kt)("span",{parentName:"span",className:"mrel"},"\u2248"),(0,a.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2778em"}})),(0,a.kt)("span",{parentName:"span",className:"base"},(0,a.kt)("span",{parentName:"span",className:"strut",style:{height:"0.6444em"}}),(0,a.kt)("span",{parentName:"span",className:"mord"},"358.3")))))," Impulse pro Umdrehung (CPR - counts per revolution)."),(0,a.kt)("p",null,"Die Tabelle gibt eine \xdcbersicht \xfcber die verschiedener Encoder-Aufl\xf6sungen (Encoderimpulse pro Radumdrehung)."),(0,a.kt)("div",{className:"centerTab"},(0,a.kt)("table",null,(0,a.kt)("thead",{parentName:"table"},(0,a.kt)("tr",{parentName:"thead"},(0,a.kt)("th",{parentName:"tr",align:null},"Roboter"),(0,a.kt)("th",{parentName:"tr",align:null},"Ausf\xfchrung"),(0,a.kt)("th",{parentName:"tr",align:null},"Getriebe"),(0,a.kt)("th",{parentName:"tr",align:null},"Encoderimpulse"))),(0,a.kt)("tbody",{parentName:"table"},(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"Zumo 32u4"),(0,a.kt)("td",{parentName:"tr",align:null},"Standard"),(0,a.kt)("td",{parentName:"tr",align:null},"75.81:1"),(0,a.kt)("td",{parentName:"tr",align:null},"909,7")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"3pi+ 32u4"),(0,a.kt)("td",{parentName:"tr",align:null},"Standard"),(0,a.kt)("td",{parentName:"tr",align:null},"29.86:1"),(0,a.kt)("td",{parentName:"tr",align:null},"358.3")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"3pi+ 32u4"),(0,a.kt)("td",{parentName:"tr",align:null},"Turtle"),(0,a.kt)("td",{parentName:"tr",align:null},"75.81:1"),(0,a.kt)("td",{parentName:"tr",align:null},"909,7"))))),(0,a.kt)("img",{src:"/img/robotik/RadEncoder.png",alt:"Ein Radencoder f\xfcr die Odometrie",width:"450px",className:"center"}),(0,a.kt)("h3",{id:"quadratur-encoder-quadrature-encoder"},"Quadratur-Encoder (",(0,a.kt)("em",{parentName:"h3"},"Quadrature Encoder"),")"),(0,a.kt)("p",null,"Der oben dargestellte Rad-Encoder ist ein sehr einfacher Inkrementalgeber. Was diesem Encoder fehlt, ist die M\xf6glichkeit die Drehrichtung des Rades zu bestimmen. Ein Quadratur-Encoder schafft hier Abhilfe. "),(0,a.kt)("p",null,"Bei einem Quadratur-Encoder wird das Rad nicht mit einem Sensor, sondern mit ",(0,a.kt)("strong",{parentName:"p"},"zwei r\xe4umlich versetzten Sensoren")," abgetastet. Dadurch ergibt sich nicht nur eine Impulsfolge, welche angibt, wie weit sich das Rad gedreht hat, sondern ",(0,a.kt)("strong",{parentName:"p"},"zwei Impulsfolgen (A und B)")," aus welchen zus\xe4tzlich auch die Drehrichtung bestimmt werden kann. "),(0,a.kt)("h4",{id:"drehrichtung-im-uhrzeigersinn"},"Drehrichtung im Uhrzeigersinn"),(0,a.kt)("p",null,"In der dargestellten Abbilung sind die beiden Encoder-Sensoren mit den Buchstaben A und B bezeichnet. Der rechte Sensor (A) ist bei einer Drehung im ",(0,a.kt)("strong",{parentName:"p"},"Uhrzeigersinn")," der Sensor, welcher zuerst die Zustands\xe4nderungen (von 0 auf 1 oder andersrum) detektiert. Der Sensor B wird die selbe Zustands\xe4nderung kurz danach detektieren. Das bedeutet, dass direkt nach dem Zustandswechsel des Sensors A, der Sensor B noch im alten Zustand ist. "),(0,a.kt)("p",null,"Bei einer ",(0,a.kt)("strong",{parentName:"p"},"Drehung im Uhrzeigersinn")," gilt bei der Zustands\xe4nderung des Sensors B: ",(0,a.kt)("inlineCode",{parentName:"p"},"B=!A"),"."),(0,a.kt)("img",{src:"/img/robotik/QuadEncoderClockwise.png",alt:"Quadratur Encoder",width:"620",className:"center"}),(0,a.kt)("h4",{id:"drehrichtung-entgegen-dem-uhrzeigersinn"},"Drehrichtung entgegen dem Uhrzeigersinn"),(0,a.kt)("p",null,"Dreht sich das Rad entgegen dem Uhrzeigersinn ist der Sensor B der f\xfchrende Sensor und erkennt die Zustands\xe4nderung als erstes. Aus Sicht des Sensors A bedeutet das, dass der Sensor A bei einer Zustands\xe4nderung den bereits detektierten Zustand vom Sensor B annimmt."),(0,a.kt)("p",null,"Bei einer ",(0,a.kt)("strong",{parentName:"p"},"Drehung entgegen dem Uhrzeigersinn")," gilt bei der Zustands\xe4nderung des Sensors B: ",(0,a.kt)("inlineCode",{parentName:"p"},"B=A"),"."),(0,a.kt)("img",{src:"/img/robotik/QuadEncoderCC.png",alt:"Quadratur Encoder",width:"620",className:"center"}),(0,a.kt)("h2",{id:"auslesen-der-rad-encoder-beim-3pi-32u4--zumo-32u4"},"Auslesen der Rad-Encoder beim 3pi+ 32u4 / Zumo 32u4"),(0,a.kt)("p",null,"In der Bibliothek f\xfcr den 3pi+ 32u4 wird die Klasse ",(0,a.kt)("inlineCode",{parentName:"p"},"Encoders")," bereitgestellt (beim Zumo 32u4 die Klasse ",(0,a.kt)("inlineCode",{parentName:"p"},"Zumo32U4Encoders"),"), welche es mit den Methode ",(0,a.kt)("inlineCode",{parentName:"p"},"getCountsLeft()")," und ",(0,a.kt)("inlineCode",{parentName:"p"},"getCountsRight()")," erm\xf6glicht, die vom Encoder gemessenen Impulse auszugeben. "),(0,a.kt)("p",null,"Die Methoden zum Auslesen der Rad-Encoder verwenden im Hintergrund so genannte ",(0,a.kt)("a",{parentName:"p",href:"https://de.wikipedia.org/wiki/Interrupt"},"Interrupt-Funktionen"),", welche jedes Mal, wenn die Encoder einen Impuls erhalten, eine globale Variable im eins erh\xf6hen oder verringern (abh\xe4ngig von der Drehrichtung). Die Methoden ",(0,a.kt)("inlineCode",{parentName:"p"},"getCountsLeft()")," und ",(0,a.kt)("inlineCode",{parentName:"p"},"getCountsRight()")," geben dann die aktuelle Anzahl der aufsummierten Impulse pro Rad an."),(0,a.kt)("p",null,"Die Methoden ",(0,a.kt)("inlineCode",{parentName:"p"},"getCountsAndResetLeft()")," und ",(0,a.kt)("inlineCode",{parentName:"p"},"getCountsAndResetRight()")," verhalten sich \xe4hnlich, setzten jedoch die entsprechende globale Variable f\xfcr die aufsummierten Impulse zur\xfcck."),(0,a.kt)("admonition",{type:"caution"},(0,a.kt)("p",{parentName:"admonition"},"Damit die globalen Z\xe4hler f\xfcr die Encoder-Impulse nicht \xfcberlaufen, sollten regelm\xe4\xdfig die Funktionen ",(0,a.kt)("inlineCode",{parentName:"p"},"getCountsAndResetLeft()")," und ",(0,a.kt)("inlineCode",{parentName:"p"},"getCountsAndResetRight()")," aufgerufen werden.")),(0,a.kt)("h3",{id:"beispiel"},"Beispiel"),(0,a.kt)(i.Z,{mdxType:"Tabs"},(0,a.kt)(l.Z,{value:"3pi+",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-arduino"},"// Zeigt die Encoder-Werte auf dem Display an\n#include <Wire.h>\n#include <Pololu3piPlus32U4.h>\nusing namespace Pololu3piPlus32U4;\n\nEncoders encoders; //  Encoder-Objekt deklarieren\nOLED oled;\n\nunsigned long lastDisplayTime = 0;\n\nvoid setup() {\n  // bleibt leer\n}\n\nvoid loop() {\n  if ((millis() - lastDisplayTime) >= 100) {\n\n    int countsLeft = encoders.getCountsLeft();   // Aufruf der getCountsLeft() Methode\n    int countsRight = encoders.getCountsRight(); // Aufruf der getCountsLeft() Methode\n\n    oled.clear();\n    oled.print(countsLeft);\n    oled.gotoXY(0, 1);\n    oled.print(countsRight);\n    \n    lastDisplayTime = millis();\n  }\n}\n"))),(0,a.kt)(l.Z,{value:"Zumo",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-arduino"},"// Zeigt die Encoder-Werte auf dem Display an\n\n#include <Wire.h>\n#include <Zumo32U4.h>\n\nZumo32U4Encoders encoders; //  Encoder-Objekt deklarieren\nZumo32U4LCD lcd;\n\nunsigned long lastDisplayTime = 0;\n\nvoid setup() {\n  // bleibt leer\n}\n\nvoid loop() {\n  if ((millis() - lastDisplayTime) >= 100) {\n\n    int countsLeft = encoders.getCountsLeft();   // Aufruf der getCountsLeft() Methode\n    int countsRight = encoders.getCountsRight(); // Aufruf der getCountsLeft() Methode\n\n    lcd.clear();\n    lcd.print(countsLeft);\n    lcd.gotoXY(0, 1);\n    lcd.print(countsRight);\n    \n    lastDisplayTime = millis();\n  }\n}\n")))),(0,a.kt)("details",{className:"ueben"}," ",(0,a.kt)("summary",null,"Aufgaben"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Die Radencoder haben eine Aufl\xf6sung von 909,7 Impulsen pro Rad-Umdrehung. Bestimmen Sie rechnerisch, wie weit der zur\xfcckgelegte Weg zwischen zwei Encoder-Impulsen ist (Millimeter pro Impuls).\n",(0,a.kt)("em",{parentName:"li"},"Hinweis: Messen Sie den Durchmesser der R\xe4der.")),(0,a.kt)("li",{parentName:"ol"},"Messen Sie die Anzahl der Encoder-Impulse die ben\xf6tigt werden, um eine Strecke von exakt 20 cm zur\xfcckzulegen. Bestimmen Sie hieraus die Encoder-Aufl\xf6sung (in Millimeter pro Impulse)."),(0,a.kt)("li",{parentName:"ol"},"Schreiben Sie ein Programm, welches den Roboter mit Hilfe der Rad-Encoder ",(0,a.kt)("strong",{parentName:"li"},"exakt")," 20 cm weit fahren l\xe4sst. Geben Sie auf dem Display die gefahrene Strecke in Millimetern an. Vergleichen Sie Ihr Ergebnis mit der Aufgabe 2. (Die zur\xfcckgelegt Strecke sollte als Mittelwert aus den beiden Rad-Encodern berechnet werden.)"),(0,a.kt)("li",{parentName:"ol"},"Wiederholen Sie die letzte Aufgabe. Versuchen Sie jedoch den Roboter die 20 cm so schnell wie m\xf6glich zur\xfccklegen zu lassen. Messen Sie die Zeit. (",(0,a.kt)("em",{parentName:"li"},"Hinweis: Nutzen Sie einen geeigneten Regler"),")"))),(0,a.kt)("h2",{id:"links"},"Links"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://lastminuteengineers.com/rotary-encoder-arduino-tutorial/"},"How Rotary Encoder Works and Interface It with Arduino")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://www.pololu.com/docs/0J63/all#3.4"},"Quadratur-Encoder des Zumo 32u4"))))}g.isMDXComponent=!0}}]);