"use strict";(self.webpackChunkspace_hal_2=self.webpackChunkspace_hal_2||[]).push([[7558],{3905:function(e,n,r){r.d(n,{Zo:function(){return d},kt:function(){return k}});var t=r(7294);function i(e,n,r){return n in e?Object.defineProperty(e,n,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[n]=r,e}function a(e,n){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),r.push.apply(r,t)}return r}function u(e){for(var n=1;n<arguments.length;n++){var r=null!=arguments[n]?arguments[n]:{};n%2?a(Object(r),!0).forEach((function(n){i(e,n,r[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):a(Object(r)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(r,n))}))}return e}function l(e,n){if(null==e)return{};var r,t,i=function(e,n){if(null==e)return{};var r,t,i={},a=Object.keys(e);for(t=0;t<a.length;t++)r=a[t],n.indexOf(r)>=0||(i[r]=e[r]);return i}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(t=0;t<a.length;t++)r=a[t],n.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(i[r]=e[r])}return i}var o=t.createContext({}),s=function(e){var n=t.useContext(o),r=n;return e&&(r="function"==typeof e?e(n):u(u({},n),e)),r},d=function(e){var n=s(e.components);return t.createElement(o.Provider,{value:n},e.children)},g={inlineCode:"code",wrapper:function(e){var n=e.children;return t.createElement(t.Fragment,{},n)}},p=t.forwardRef((function(e,n){var r=e.components,i=e.mdxType,a=e.originalType,o=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),p=s(r),k=i,c=p["".concat(o,".").concat(k)]||p[k]||g[k]||a;return r?t.createElement(c,u(u({ref:n},d),{},{components:r})):t.createElement(c,u({ref:n},d))}));function k(e,n){var r=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var a=r.length,u=new Array(a);u[0]=p;var l={};for(var o in n)hasOwnProperty.call(n,o)&&(l[o]=n[o]);l.originalType=e,l.mdxType="string"==typeof e?e:i,u[1]=l;for(var s=2;s<a;s++)u[s]=r[s];return t.createElement.apply(null,u)}return t.createElement.apply(null,r)}p.displayName="MDXCreateElement"},9779:function(e,n,r){r.r(n),r.d(n,{frontMatter:function(){return l},contentTitle:function(){return o},metadata:function(){return s},toc:function(){return d},default:function(){return p}});var t=r(3117),i=r(102),a=(r(7294),r(3905)),u=["components"],l={title:"Mit einem Roboter ein Labyrinth l\xf6sen",sidebar_label:"Labyrinth",custom_edit_url:null,keywords:["Arduino","Roboter","Linienfolger","Zumo 32U4","Labyrinth","Labyrinth l\xf6sen","Rechte Hand Regel","Linke Hand Regel","Linke Hand Regel Labyrinth","Rechte Hand Regel Labyrinth","Labyrinth Algorithmus"]},o=void 0,s={unversionedId:"robotik/maze",id:"robotik/maze",title:"Mit einem Roboter ein Labyrinth l\xf6sen",description:"~ UNDER CONSTRUCTION ~",source:"@site/docs/robotik/maze.md",sourceDirName:"robotik",slug:"/robotik/maze",permalink:"/docs/robotik/maze",editUrl:null,tags:[],version:"current",frontMatter:{title:"Mit einem Roboter ein Labyrinth l\xf6sen",sidebar_label:"Labyrinth",custom_edit_url:null,keywords:["Arduino","Roboter","Linienfolger","Zumo 32U4","Labyrinth","Labyrinth l\xf6sen","Rechte Hand Regel","Linke Hand Regel","Linke Hand Regel Labyrinth","Rechte Hand Regel Labyrinth","Labyrinth Algorithmus"]},sidebar:"sideBarRobotik",previous:{title:"Suchen und Ausrichten",permalink:"/docs/robotik/objektFinden"},next:{title:"Gitternavigation",permalink:"/docs/robotik/gridNavigation"}},d=[{value:"Kreuzungen",id:"kreuzungen",children:[{value:"Aufz\xe4hlungsdatentyp <code>enum</code> f\xfcr die Kreuzungstypen",id:"aufz\xe4hlungsdatentyp-enum-f\xfcr-die-kreuzungstypen",children:[],level:3},{value:"Erkennen der Kreuzungen",id:"erkennen-der-kreuzungen",children:[],level:3},{value:"Funktion <code>erkennenKreuzung()</code>",id:"funktion-erkennenkreuzung",children:[],level:3}],level:2},{value:"Abbiegen an Kreuzungen",id:"abbiegen-an-kreuzungen",children:[],level:2},{value:"L\xf6sen des Labyrinths mit Rechter-Hand-Regel",id:"l\xf6sen-des-labyrinths-mit-rechter-hand-regel",children:[],level:2},{value:"Optimierung der Rechten-Hand-Regel",id:"optimierung-der-rechten-hand-regel",children:[],level:2},{value:"Links",id:"links",children:[],level:2}],g={toc:d};function p(e){var n=e.components,r=(0,i.Z)(e,u);return(0,a.kt)("wrapper",(0,t.Z)({},g,r,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"~ UNDER CONSTRUCTION ~")),(0,a.kt)("p",null,"Neben dem ",(0,a.kt)("a",{parentName:"p",href:"/docs/robotik/edgeFollower"},"Linienfolger")," ist das L\xf6sen eines Labyrinths eine weitere sehr ",(0,a.kt)("a",{parentName:"p",href:"https://www.youtube.com/watch?v=2V6QE0GJ-zw"},"beliebte")," Aufgabe f\xfcr kleine Roboter. Labyrinthe gibt es in vielen verschiedenen Formen und Gr\xf6\xdfen. Die im Folgenden beschriebenen Ans\xe4tze und Ideen beziehen sich alle auf Labyrinthe, bei denen die Pfade mit einer schwarzen Linie auf wei\xdfem Grund dargestellt sind und Abzweigungen immer im 90 Grad Winkel erfolgen. "),(0,a.kt)("p",null,"Auch wenn sich die Programmausz\xfcge auf den ",(0,a.kt)("strong",{parentName:"p"},"Roboter Zumo 32u4")," der Firma Pololu beziehen, sind die Erl\xe4uterungen sehr allgemeiner Natur und sollten sich problemlos auf andere Roboter \xfcberagen lassen."),(0,a.kt)("img",{src:"/img/robotik/MazeOverview.png",alt:"Allgemeines Labyrinth",width:"400px",className:"center"}),(0,a.kt)("p",null,"Im wesentlichen kann das L\xf6sen eines Labyrinths in ",(0,a.kt)("strong",{parentName:"p"},"vier unterschiedliche Teilaufgaben")," unterteilt werden:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Der Roboter muss einer ",(0,a.kt)("strong",{parentName:"li"},"Linie folgen")," k\xf6nnen. "),(0,a.kt)("li",{parentName:"ol"},"Der Roboter muss ",(0,a.kt)("strong",{parentName:"li"},"Kreuzungen")," bzw. Abzweigungen korrekt ",(0,a.kt)("strong",{parentName:"li"},"erkennen"),"."),(0,a.kt)("li",{parentName:"ol"},"Der Roboter muss an einer Kreuzung zu jeden beliebigen Weg ",(0,a.kt)("strong",{parentName:"li"},"abbiegen")," k\xf6nnen. "),(0,a.kt)("li",{parentName:"ol"},"Der Roboter ben\xf6tigt Regeln, die beschreiben, wie er das ",(0,a.kt)("strong",{parentName:"li"},"Ziel des Labyrinths findet"),".")),(0,a.kt)("p",null,"Der Algorithmus f\xfcr den Linienfolger (",(0,a.kt)("a",{parentName:"p",href:"/docs/robotik/edge_P_Control"},"P-Regler"),", ",(0,a.kt)("a",{parentName:"p",href:"/docs/robotik/lineFollowerPD"},"PD-Regler"),") wurde bereits an anderer Stelle besprochen und muss hier nicht wiederholt werden. Bleibt das Erkennen der Kreuzungen, das Abbiegen an Kreuzung und der eigentliche Algorithms zum L\xf6sen des Labyrinths."),(0,a.kt)("h2",{id:"kreuzungen"},"Kreuzungen"),(0,a.kt)("p",null,"Die Kreuzungserkennung des Roboters soll alle Kreuzungen (Abzweigungen), Sackgassen und das Ziel (Ende) des Labyrinths erkennen. Insgesamt gibt es 8 zu erkennende ",(0,a.kt)("em",{parentName:"p"},"Events")," (Kreuzung, Sackgasse, Ziel), welche in der folgenden Abbildung dargestellt sind. Jedem Event wird in der Abbildung eine Abk\xfcrzung (L,R, LG, RG, etc.) zugewiesen, welche sp\xe4ter im Programm f\xfcr das L\xf6sen des Labyrinths wichtig sein wird."),(0,a.kt)("p",null,"Au\xdferdem sind in der Abbildung die f\xfcnf Bodensensoren des Zumo 32u4 dargestellt, mit denen der Roboter die Kreuzungstypen erkennen kann. "),(0,a.kt)("img",{src:"/img/robotik/IntersectionTypes.png",alt:"Kreuzungstypen beim Labyrinth",width:"600px",className:"center"}),(0,a.kt)("h3",{id:"aufz\xe4hlungsdatentyp-enum-f\xfcr-die-kreuzungstypen"},"Aufz\xe4hlungsdatentyp ",(0,a.kt)("inlineCode",{parentName:"h3"},"enum")," f\xfcr die Kreuzungstypen"),(0,a.kt)("p",null,"\xc4hnlich wie bei den ",(0,a.kt)("a",{parentName:"p",href:"/docs/arduino/stateMachine#enum-aufz%C3%A4hlungstyp"},"endlichen Automaten"),", macht es auch bei den Kreuzungstypen Sinn, einen eigenen Datentyp (",(0,a.kt)("inlineCode",{parentName:"p"},"KreuzungsTyp"),") f\xfcr die verschiedenen Kreuzungen zu erstellen."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"enum KreuzungsTyp {L, R, LR, LS, RG, LRG, S, ZIEL}; // Deklaration eines neuen Datentyps `KreuzungsTyp`\n")),(0,a.kt)("p",null,"Damit l\xe4sst sich dann eine Variable vom erstellten Datentyp ",(0,a.kt)("inlineCode",{parentName:"p"},"KreuzungsTyp")," deklarieren und ihr zum Beispiel der Wert ",(0,a.kt)("inlineCode",{parentName:"p"},"LRG")," f\xfcr eine Kreuzung mit 4 Abzweigungen zuweisen (Bezeichnung der Kreuzungen siehe ",(0,a.kt)("a",{parentName:"p",href:"#kreuzungserkennung"},"Abbildung oben"),")"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"KreuzungsTyp kreuzung = LRG;\n")),(0,a.kt)("p",null,"Au\xdferdem kann eine Funktion ",(0,a.kt)("inlineCode",{parentName:"p"},"erkennenKreuzung()")," definiert werden, deren R\xfcckgabewerte vom Typ ",(0,a.kt)("inlineCode",{parentName:"p"},"KreuzungsTyp")," sind:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"KreuzungsTyp erkenneKreuzung(){\n    // Funktionsbeschreibung\n}\n")),(0,a.kt)("p",null,"Dadurch l\xe4sst sich die gesamte ",(0,a.kt)("em",{parentName:"p"},"Kreuzungserkennung")," (mit Sackgasse und Ziel) in einer Funktion ",(0,a.kt)("inlineCode",{parentName:"p"},"erkenneKreuzung()")," durchf\xfchren und das Ergebnis wird als neuer Datentyp ",(0,a.kt)("inlineCode",{parentName:"p"},"KreuzungsTyp")," zur\xfcckgegeben. Das vollst\xe4ndige Programm zum L\xf6sen des Labyrinths wird damit deutlich lesbarer und strukturierter."),(0,a.kt)("h3",{id:"erkennen-der-kreuzungen"},"Erkennen der Kreuzungen"),(0,a.kt)("p",null,"Nachdem die Kreuzungstypen bekannt sind, erfolgt das ",(0,a.kt)("strong",{parentName:"p"},"Erkennen der Kreuzungen")," in drei Schritten, die in der n\xe4chsten Abbildung dargestellt sind."),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Der Roboter folgt so lange der Linie, bis einer der \xe4u\xdferen Sensoren eine Abzweigung erkennt (",(0,a.kt)("em",{parentName:"li"},"Welche Bedingung muss f\xfcr eine Sackgasse erf\xfcllt sein?"),")"),(0,a.kt)("li",{parentName:"ol"},"Wurde eine Abzweigung erkannt, sollte der Roboter bis auf die Mitte der Linie fahren. Dort wird erneut ",(0,a.kt)("strong",{parentName:"li"},"auf Abzweigungen \xfcberpr\xfcft"),". Dadurch wird sicher gestellt, dass alle Abzweigungen erkannt werden, auch wenn der Roboter nicht ganz senkrecht auf die Abzweigungen trifft."),(0,a.kt)("li",{parentName:"ol"},"Im n\xe4chsten Schritt f\xe4hrt der Roboter \xfcber die Linie hinweg. F\xfcr das sp\xe4ter folgende Abbiegen ist es am besten, wenn er genau mittig auf der Kreuzung stehen bleibt. Nun kann der Roboter \xfcberpr\xfcfen, ob es auch einen zus\xe4tzlichen ",(0,a.kt)("strong",{parentName:"li"},"Weg geradeaus")," gibt oder ob des Ziel erreicht wurde.")),(0,a.kt)("img",{src:"/img/robotik/IntersectionErkennung.png",alt:"Kreuzungstypen erkennen",width:"580",className:"center"}),(0,a.kt)("p",null,"Damit der Roboter die Kreuzungen zuverl\xe4ssig erkennt, sollte f\xfcr die Positionierung auf der Linie (2. Schritt) und der Positionierung mittig auf der Kreuzung (3. Schritt) der ",(0,a.kt)("a",{parentName:"p",href:"/docs/robotik/wheelEncoder#auslesen-der-rad-encoder-beim-zumo-32u4"},"Motorencoder")," verwendet werden. Eine einfache Positionierung mit einer Zeitsteuerung kann gelegentlich funktionieren, stellt aber eine sehr fehleranf\xe4llige L\xf6sung dar."),(0,a.kt)("h3",{id:"funktion-erkennenkreuzung"},"Funktion ",(0,a.kt)("inlineCode",{parentName:"h3"},"erkennenKreuzung()")),(0,a.kt)("p",null,"Bleibt als N\xe4chstes die Aufgabe die drei Schritte zur Kreuzungserkennung als zu ",(0,a.kt)("strong",{parentName:"p"},"programmieren"),". Ohne die fertige Funktion an dieser Stelle zu pr\xe4sentieren, sollen trotzdem ein paar Hinweise zu Realisierung gegeben werden."),(0,a.kt)("p",null,"Bevor die Funktion `",(0,a.kt)("inlineCode",{parentName:"p"},"erkennenKreuzung()")," n\xe4her besprochen wird, soll f\xfcr eine bessere Lesbarkeit die Funktion ",(0,a.kt)("inlineCode",{parentName:"p"},"bool aufLinie(byte pSensor)")," definiert werden. Die Funktion gibt ",(0,a.kt)("inlineCode",{parentName:"p"},"true")," zur\xfcck, wenn sich der angegebene Bodensensor \xfcber einer schwarzen Linie befindet und ",(0,a.kt)("inlineCode",{parentName:"p"},"false"),", wenn der Sensor keine Linie erkannt hat."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"// Die Funktion aktualisiert NICHT die Sensorwerte. \n// Zum Auslesen der Sensoren die Funktion readCalibrated() aufrufen.\nbool aufLinie(byte pSensor) {\n  const int schwelleLinie = 100;                    // Schwellert zum Erkennen einer Abzweigung\n  return lineSensorValues[pSensor] > schwelleLinie; // globaler Array `lineSensorValues[]`\n}\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"#define COUNTS_TO_MM_75_1 0.1381375246  //  Impulse * MM_TO_COUNTS_75_1 = MM (Umrechnung Impulse in mm)\nvoid fahrenStreckeMM{int pSpeed, int pStreckeMM}{\n\n\n}\n")),(0,a.kt)("p",null,"Mit der Funktion ",(0,a.kt)("inlineCode",{parentName:"p"},"aufLinie()")," kann dann in der Funktion ",(0,a.kt)("inlineCode",{parentName:"p"},"erkenneKreuzung()")," \xfcbepr\xfcft werden, ob es eine ",(0,a.kt)("strong",{parentName:"p"},"Abzweigung")," nach links, bzw. nach rechts gibt und ob ein weiterer Weg geradeaus f\xfchrt. Wurden die entsprechenden Wege erkannt, kann das in den boolschen Variablen ",(0,a.kt)("inlineCode",{parentName:"p"},"lLinks"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"lRechts")," und ",(0,a.kt)("inlineCode",{parentName:"p"},"lGerade")," abgespeichert werden."),(0,a.kt)("p",null,"Anschlie\xdfend wird der sich aus der ",(0,a.kt)("a",{parentName:"p",href:"#kreuzungserkennung"},"\xdcbersicht")," ",(0,a.kt)("strong",{parentName:"p"},"ergebende Kreuzungstyp")," ermittelt und als Wert vom Typ ",(0,a.kt)("inlineCode",{parentName:"p"},"KreuzungsTyp")," (also ",(0,a.kt)("inlineCode",{parentName:"p"},"L"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"R"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"LG"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"RG"),", etc.) von der Funktion zur\xfcckgegeben."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"KreuzungsTyp erkenneKreuzung(){\n    bool lLinks  = 0;   // Abzweigung links (m\xf6gliche Abzweigungen an der Kreuzung)\n    bool lRechts = 0;   // Abzweigungs rechts\n    bool lGerade = 0;   // Weg gereadeaus\n    \n    /*\n        1. Die Sensoren auf die Mitte der Linie positionieren (Motorencodeer verwenden).\n        2. Sensorwerte einlesen.\n        3. Abzweigungen bestimmten und lLinks/lRechts entsprechend setzen.\n        4. Weiterfahren, bis der Roboter mittig auf der Kreuzung steht.\n        5. Sensorwerte einlesen\n        6. lGerade setzen und auf Ziel \xfcberpr\xfcfen\n    */\n\n    // Funktion gibt mit `return` den ermittelten KreuzungsTyp zur\xfcck\n    if (/* Abzweigung links */){\n        return L;\n    }\n    else if (/* Abzweigung rechts */){\n        return R;\n    }\n    else if (/* Abzweigung links, gerade*/){\n        return LG;\n    }\n    /* usw. */\n}\n")),(0,a.kt)("details",{className:"ueben"}," ",(0,a.kt)("summary",null,"Aufgaben"),(0,a.kt)("p",null,"Schreiben Sie ein Programm, welches den Roboter die verschiedenen ",(0,a.kt)("strong",{parentName:"p"},"Kreuzungstypen erkennen")," l\xe4sst und auf dem Display anzeigt. Hierf\xfcr soll der Roboter auf Knopfdruck der Linie bis zu einer Kreuzung folgen. Nachdem die Kreuzung erkannt wurde, bleibt der Roboter stehen. Auf Knopfdruck folgt er erneut der Linie bis zur n\xe4chsten Kreuzung.")),(0,a.kt)("h2",{id:"abbiegen-an-kreuzungen"},"Abbiegen an Kreuzungen"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"void drehenZumAbzweig(int pRichtung){\n    if (pRichtung == 1){        // gegen den Uhrzeigersinn bis zur n\xe4chsten Abzweigung drehen\n        // Drehen, bis der Roboter auf der Linie steht\n    }\n    else if (pRichtung == -1){  // mit den Uhrzeigersinn bis zur n\xe4chsten Abzweigung drehen\n        // Drehen, bis der Roboter auf der Linie steht\n    }\n}\n")),(0,a.kt)("h2",{id:"l\xf6sen-des-labyrinths-mit-rechter-hand-regel"},"L\xf6sen des Labyrinths mit Rechter-Hand-Regel"),(0,a.kt)("img",{src:"/img/robotik/mazeRHR_1.png",alt:"Labyrinth Rechte-Hand-Regel",width:"400",className:"center"}),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"void anwendenRHR(){ // RHR: Rechte-Hand-Regel\n  bool end = false;\n\n  while (!end){\n    KreuzungsTyp kreuzung;\n\n    kreuzung = geheNaechsteKreuzung();\n\n    switch(kreuzung){\n        /*\n        Anweisungen f\xfcr die verschiedenen Kreuzungen\n        */\n    }\n\n}\n\n")),(0,a.kt)("h2",{id:"optimierung-der-rechten-hand-regel"},"Optimierung der Rechten-Hand-Regel"),(0,a.kt)("img",{src:"/img/robotik/mazeRHR_2.png",alt:"Labyrinth Rechte-Hand-Regel",width:"400",className:"center"}),(0,a.kt)("img",{src:"/img/robotik/mazeRHR_3.png",alt:"Labyrinth Rechte-Hand-Regel",width:"400",className:"center"}),(0,a.kt)("h2",{id:"links"},"Links"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://patrickmccabemakes.com/tutorials/Maze_Solving/"},"Maze Solving")," "),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://www.pololu.com/file/0J195/line-maze-algorithm.pdf"},"Teaching a Robot to Solve a Line Maze"))))}p.isMDXComponent=!0}}]);